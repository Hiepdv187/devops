<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>PageFlipper</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;600;700&family=Lora:wght@400;500;600&display=swap" rel="stylesheet">
<style>
/* General styles from globals.css and layout */
:root {
  --background: 220 25% 10%;
  --foreground: 220 20% 90%;
  --card: 220 25% 15%;
  --card-foreground: 220 20% 90%;
  --primary: 210 80% 60%;
  --primary-foreground: 210 80% 10%;
  --accent: 200 90% 50%;
  --accent-foreground: 200 90% 95%;
  --border: 220 25% 30%;
  --muted-foreground: 220 15% 55%;
  --highlight-yellow: hsla(55, 100%, 50%, 0.4);
  --highlight-pink: hsla(330, 100%, 50%, 0.4);
  --highlight-blue: hsla(210, 100%, 50%, 0.4);
  --highlight-green: hsla(130, 100%, 50%, 0.4);
}
body {
  font-family: 'Literata', serif;
  background-color: hsl(var(--background));
  color: hsl(var(--foreground));
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  font-family: Arial, Helvetica, sans-serif;
  overflow-x: hidden;
}
main {
  display: flex;
  min-height: 100vh;
  width: 100%;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 1rem 0; /* Add some vertical padding */
}
.pageflipper-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  font-family: 'Literata', serif;
  width: 100%;
}

/* Editor Toolbar */
.editor-toolbar {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    padding: 0.5rem 1rem;
    background-color: hsl(var(--card));
    border: 1px solid hsl(var(--border));
    border-radius: 8px;
    margin-bottom: 1rem;
    box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
}
.toolbar-button {
    background: none;
    border: none;
    color: hsl(var(--foreground));
    cursor: pointer;
    padding: 0.5rem;
    border-radius: 4px;
    display: flex;
    align-items: center;
    justify-content: center;
}
.toolbar-button:hover {
    background-color: hsl(var(--border));
}
.toolbar-button.active {
    background-color: hsl(var(--primary));
    color: hsl(var(--primary-foreground));
}
.toolbar-button svg {
    width: 1rem;
    height: 1rem;
}


/* page-flipper.css */
.book-container {
  width: 90vw;
  height: 80vh;
  max-width: 1200px;
  max-height: 800px;
  position: relative;
  perspective: 2500px;
  transition: transform 0.5s;
}
.book-container.closed {
    transform: scaleX(0.7);
}
.sheet {
  position: absolute;
  width: 50%;
  height: 100%;
  top: 0;
  left: 50%;
  transform-origin: left center;
  transition: transform 0.5s ease-in-out;
  transform-style: preserve-3d;
  box-shadow: 0 4px 20px rgba(0,0,0,0.2);
}
.sheet.flipped {
  transform: rotateY(-180deg);
}
.page {
  position: absolute;
  width: 100%;
  height: 100%;
  backface-visibility: hidden;
  background-color: hsl(var(--card));
  border: 1px solid hsl(var(--border));
  overflow: visible; /* Allow tooltips to overflow */
  pointer-events: auto; /* Enable interactions by default */
}
.sheet:not(.flipped) .page-back {
  pointer-events: none;
}
.sheet.flipped .page-front {
  pointer-events: none;
}
.page-front {
  border-radius: 0 8px 8px 0;
}
.page-back {
  transform: rotateY(180deg);
  border-radius: 8px 0 0 8px;
  /* Fix rendering issues with rotated pages */
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  filter: brightness(1) !important;
  opacity: 1 !important;
}
.page.is-cover, .page.is-back-cover {
  background-color: hsl(var(--accent));
  color: hsl(var(--accent-foreground));
}

/* Neon border with smooth fade in/out effect */
.page.is-cover,
.page.is-back-cover {
  animation: neonBorderCycle 15s linear infinite;
}

@keyframes neonBorderCycle {
  /* Pink neon - 0-20% (3s) */
  0% {
    box-shadow: 0 0 2px #ff0080, 0 0 3px #ff0080;
  }
  3% {
    box-shadow: 0 0 4px #ff0080, 0 0 6px #ff0080, 0 0 8px #ff0080;
  }
  6% {
    box-shadow: 0 0 6px #ff0080, 0 0 10px #ff0080, 0 0 14px #ff0080;
  }
  10% {
    box-shadow: 0 0 8px #ff0080, 0 0 12px #ff0080, 0 0 18px #ff0080;
  }
  14% {
    box-shadow: 0 0 6px #ff0080, 0 0 10px #ff0080, 0 0 14px #ff0080;
  }
  17% {
    box-shadow: 0 0 4px #ff0080, 0 0 6px #ff0080, 0 0 8px #ff0080;
  }
  20% {
    box-shadow: 0 0 2px #ff0080, 0 0 3px #ff0080;
  }
  
  /* Orange neon - 20-40% (3s) */
  20% {
    box-shadow: 0 0 2px #ff8c00, 0 0 3px #ff8c00;
  }
  23% {
    box-shadow: 0 0 4px #ff8c00, 0 0 6px #ff8c00, 0 0 8px #ff8c00;
  }
  26% {
    box-shadow: 0 0 6px #ff8c00, 0 0 10px #ff8c00, 0 0 14px #ff8c00;
  }
  30% {
    box-shadow: 0 0 8px #ff8c00, 0 0 12px #ff8c00, 0 0 18px #ff8c00;
  }
  34% {
    box-shadow: 0 0 6px #ff8c00, 0 0 10px #ff8c00, 0 0 14px #ff8c00;
  }
  37% {
    box-shadow: 0 0 4px #ff8c00, 0 0 6px #ff8c00, 0 0 8px #ff8c00;
  }
  40% {
    box-shadow: 0 0 2px #ff8c00, 0 0 3px #ff8c00;
  }
  
  /* Turquoise neon - 40-60% (3s) */
  40% {
    box-shadow: 0 0 2px #40e0d0, 0 0 3px #40e0d0;
  }
  43% {
    box-shadow: 0 0 4px #40e0d0, 0 0 6px #40e0d0, 0 0 8px #40e0d0;
  }
  46% {
    box-shadow: 0 0 6px #40e0d0, 0 0 10px #40e0d0, 0 0 14px #40e0d0;
  }
  50% {
    box-shadow: 0 0 8px #40e0d0, 0 0 12px #40e0d0, 0 0 18px #40e0d0;
  }
  54% {
    box-shadow: 0 0 6px #40e0d0, 0 0 10px #40e0d0, 0 0 14px #40e0d0;
  }
  57% {
    box-shadow: 0 0 4px #40e0d0, 0 0 6px #40e0d0, 0 0 8px #40e0d0;
  }
  60% {
    box-shadow: 0 0 2px #40e0d0, 0 0 3px #40e0d0;
  }
  
  /* Purple neon - 60-80% (3s) */
  60% {
    box-shadow: 0 0 2px #9d00ff, 0 0 3px #9d00ff;
  }
  63% {
    box-shadow: 0 0 4px #9d00ff, 0 0 6px #9d00ff, 0 0 8px #9d00ff;
  }
  66% {
    box-shadow: 0 0 6px #9d00ff, 0 0 10px #9d00ff, 0 0 14px #9d00ff;
  }
  70% {
    box-shadow: 0 0 8px #9d00ff, 0 0 12px #9d00ff, 0 0 18px #9d00ff;
  }
  74% {
    box-shadow: 0 0 6px #9d00ff, 0 0 10px #9d00ff, 0 0 14px #9d00ff;
  }
  77% {
    box-shadow: 0 0 4px #9d00ff, 0 0 6px #9d00ff, 0 0 8px #9d00ff;
  }
  80% {
    box-shadow: 0 0 2px #9d00ff, 0 0 3px #9d00ff;
  }
  
  /* Green neon - 80-100% (3s) */
  80% {
    box-shadow: 0 0 2px #00ff88, 0 0 3px #00ff88;
  }
  83% {
    box-shadow: 0 0 4px #00ff88, 0 0 6px #00ff88, 0 0 8px #00ff88;
  }
  86% {
    box-shadow: 0 0 6px #00ff88, 0 0 10px #00ff88, 0 0 14px #00ff88;
  }
  90% {
    box-shadow: 0 0 8px #00ff88, 0 0 12px #00ff88, 0 0 18px #00ff88;
  }
  94% {
    box-shadow: 0 0 6px #00ff88, 0 0 10px #00ff88, 0 0 14px #00ff88;
  }
  97% {
    box-shadow: 0 0 4px #00ff88, 0 0 6px #00ff88, 0 0 8px #00ff88;
  }
  100% {
    box-shadow: 0 0 2px #00ff88, 0 0 3px #00ff88;
  }
}

/* Back cover still needs centering */
.page.is-back-cover {
  display: flex;
  align-items: center;
  justify-content: center;
  text-align: center;
}

/* Remove padding from page-content for cover to make image full */
.page.is-cover .page-content {
    padding: 0;
    display: block; /* Override flex to prevent centering */
}

/* Cover container - replaces editable-area for cover */
.page.is-cover .cover-container {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    height: 100%;
    width: 100%;
    padding: 0;
    margin: 0;
    overflow: hidden;
}

/* Background image - full cover */
.page.is-cover .cover-bg-image {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    z-index: 1;
}

/* Color overlay - medium for text readability */
.page.is-cover .cover-color-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    opacity: 0.55;
    z-index: 2;
}

/* Top left: Author and Tag */
.page.is-cover .cover-top-left {
    position: absolute;
    top: 0.5rem;
    left: 0.5rem;
    text-align: left;
    z-index: 4;
}

.page.is-cover .cover-author {
    font-size: 1.1rem;
    font-weight: 500;
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
    margin-bottom: 0.25rem;
    font-family: 'Lora', serif;
    letter-spacing: 0.3px;
}

.page.is-cover .cover-tags-container {
    position: absolute;
    bottom: 1rem;
    left: 1.5rem;
    right: 1.5rem;
    display: flex;
    flex-wrap: wrap;
    gap: 0.35rem;
    justify-content: center;
    z-index: 4;
}

.page.is-cover .cover-tag {
    font-size: 0.8rem;
    font-family: 'Lora', serif;
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
    font-style: italic;
    opacity: 0.9;
    background: rgba(255, 255, 255, 0.15);
    padding: 0.2rem 0.6rem;
    border-radius: 6px;
    white-space: nowrap;
    transform: skewX(-5deg);
    transition: all 0.2s ease;
}

.page.is-cover .cover-tag:hover {
    background: rgba(255, 255, 255, 0.25);
    transform: skewX(-5deg) scale(1.05);
}

/* Top right: Category */
.page.is-cover .cover-category {
    position: absolute;
    top: 0.5rem;
    right: 0.5rem;
    font-size: 0.85rem;
    background: rgba(0, 0, 0, 0.3);
    padding: 0.25rem 0.75rem;
    border-radius: 20px;
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    z-index: 4;
    font-family: 'Lora', serif;
    font-weight: 500;
}

/* Center: Title and Description */
.page.is-cover .cover-content-center {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 100%;
    padding: 0 2.5rem;
    text-align: center;
    z-index: 4;
}

.page.is-cover .cover-title {
    font-size: 2.2rem;
    font-weight: 600;
    margin: 0;
    padding: 0;
    text-shadow: 0 2px 8px rgba(0, 0, 0, 0.7);
    line-height: 1.2;
    font-family: 'Playfair Display', serif;
    letter-spacing: 0.5px;
    text-align: center;
    word-wrap: break-word;
    overflow-wrap: break-word;
    hyphens: auto;
    max-width: 100%;
}

.page.is-cover .cover-description {
    font-size: 1rem;
    line-height: 1.4;
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
    margin: 1rem 0 0 0;
    padding: 0;
    font-family: 'Lora', serif;
    font-weight: 400;
    text-align: center;
    word-wrap: break-word;
    overflow-wrap: break-word;
    max-width: 100%;
    opacity: 0.95;
}

.page-content {
  padding: 2rem;
  padding-bottom: 3rem; /* Space for page number */
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  box-sizing: border-box;
  overflow: visible; /* Allow tooltips to overflow */
  position: relative;
}
.page-number-left {
  position: absolute;
  bottom: 1rem;
  left: 1.5rem;
  font-size: 0.875rem;
  color: hsl(var(--muted-foreground));
  z-index: 10; /* Above editable area */
  pointer-events: none; /* Don't block clicks */
}
.page-number-right {
  position: absolute;
  bottom: 1rem;
  right: 1.5rem;
  font-size: 0.875rem;
  color: hsl(var(--muted-foreground));
  z-index: 10; /* Above editable area */
  pointer-events: none; /* Don't block clicks */
}
.editable-area {
  line-height: 1.6;
  width: 100%;
  flex: 1; /* Take remaining space */
  background-color: hsl(var(--card)); /* Solid background */
  border: 2px solid hsl(var(--accent));
  border-radius: 4px;
  position: relative;
  resize: none;
  color: hsl(var(--foreground));
  font-size: 1em;
  padding: 0.5rem; /* Padding inside border */
  padding-bottom: 2rem; /* Extra space at bottom */
  white-space: pre-wrap;
  word-wrap: break-word;
  outline: none;
  overflow-y: auto; /* Scroll on editable area only */
  overflow-x: hidden;
  box-shadow: 0 0 0 0 hsl(var(--accent));
  animation: borderGlow 3s ease-in-out infinite; /* Animation for all users */
  /* Allow tooltips to overflow */
  padding-top: 2.2rem; /* Add space at top for tooltips */
  /* Allow text selection even when not editable */
  user-select: text !important;
  -webkit-user-select: text !important;
  -moz-user-select: text !important;
  -ms-user-select: text !important;
}

/* Read-only mode for non-authors - keep animation */
.editable-area[data-is-author="false"] {
  cursor: text;
}

.editable-area[data-is-author="false"]:focus {
  box-shadow: 0 0 0 2px rgba(148, 163, 184, 0.1);
}

/* No border for cover pages */
.page.is-cover .editable-area,
.page.is-back-cover .editable-area {
  background-color: transparent; /* Cover uses page background */
  border: none;
  box-shadow: none;
  animation: none;
  padding: 0; /* Remove all padding for cover */
  padding-top: 0; /* Remove top padding that pushes content down */
  flex: none; /* Remove flex that may affect positioning */
  overflow: visible; /* Allow absolute positioned elements to show */
}

@keyframes borderGlow {
  0%, 100% {
    border-color: hsl(var(--accent));
    box-shadow: 0 0 5px hsl(var(--accent));
  }
  33% {
    border-color: hsl(210, 100%, 60%);
    box-shadow: 0 0 5px hsl(210, 100%, 60%);
  }
  66% {
    border-color: hsl(280, 100%, 60%);
    box-shadow: 0 0 5px hsl(280, 100%, 60%);
  }
}

@keyframes highlight-pulse {
  0%, 100% {
    background-color: #fef08a;
    transform: scale(1);
  }
  50% {
    background-color: #fde047;
    transform: scale(1.05);
  }
}

/* Search highlight - different from user highlights */
.search-highlight {
  background-color: #fef08a !important;
  padding: 2px 4px;
  border-radius: 2px;
  font-weight: 600;
  color: #854d0e;
}

mark.search-highlight {
  background-color: #fef08a;
  animation: highlight-pulse 1s ease-in-out 2;
}
/* Inline styles from Quill editor are preserved */
.editable-area img {
    max-width: 100%;
    height: auto;
    border-radius: 4px;
    cursor: pointer;
    user-select: none;
    -webkit-user-select: none;
}
.editable-area[contenteditable="false"] img {
    pointer-events: none;
    cursor: default;
}
.editable-area table {
  width: 100%;
  border-collapse: collapse;
  margin: 1em 0;
}
.editable-area th, .editable-area td {
  border: 1px solid hsl(var(--border));
  padding: 8px;
  min-width: 50px;
}
.editable-area th {
  background-color: hsl(var(--background));
}
.editable-area:empty:before{
  content: attr(placeholder);
  pointer-events: none;
  display: block; /* For Firefox */
  color: hsl(var(--muted-foreground));
}
mark {
    position: relative;
    cursor: pointer;
    background-color: var(--highlight-yellow);
    border-radius: 3px;
    padding: 0.1em 0.3em;
    overflow: visible; /* Allow note to overflow */
    /* Inherit all text styles from parent */
    font-size: inherit;
    font-weight: inherit;
    font-style: inherit;
    font-family: inherit;
    line-height: inherit;
    color: inherit;
    text-decoration: inherit;
}
mark:hover .highlight-note {
  display: block;
}
.highlight-note {
  display: none;
  position: absolute;
  bottom: calc(100% + 8px); /* Position above the mark */
  left: 50%;
  transform: translateX(-50%);
  background-color: #333;
  color: white;
  padding: 8px 12px;
  border-radius: 4px;
  font-size: 0.8rem;
  width: max-content;
  max-width: 250px;
  z-index: 10000; /* Very high z-index to be above everything */
  white-space: pre-wrap;
  pointer-events: none; /* Don't block mouse events */
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
  /* Add arrow pointing down */
}
.highlight-note::after {
  content: '';
  position: absolute;
  top: 100%;
  left: 50%;
  transform: translateX(-50%);
  border: 6px solid transparent;
  border-top-color: #333;
}

/* Button styles */
.button {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 0.5rem;
  white-space: nowrap;
  border-radius: 0.5rem;
  font-size: 0.875rem;
  line-height: 1.25rem;
  font-weight: 500;
  transition: all 200ms ease;
  height: 2.5rem;
  padding: 0.5rem 1rem;
  cursor: pointer;
  border: 1px solid rgba(148, 163, 184, 0.3);
  background: rgba(59, 130, 246, 0.15);
  backdrop-filter: blur(8px);
  color: #e2e8f0;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
}
.button.icon-button {
  padding: 0.5rem;
  width: 2.5rem;
}
.button:hover {
  background: rgba(59, 130, 246, 0.25);
  border-color: rgba(59, 130, 246, 0.5);
  box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
  transform: translateY(-1px);
}
.button:disabled {
  pointer-events: none;
  opacity: 0.5;
}
.button svg {
  width: 1rem;
  height: 1rem;
}
.controls {
  position: fixed;
  bottom: 1.5rem;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  width: 90%;
  max-width: 1200px;
  justify-content: center;
  align-items: center;
  gap: 1rem;
  z-index: 100;
}
.nav-buttons {
  display: flex;
  gap: 1rem;
  align-items: center;
}

/* Book Search */
.book-search-container {
  position: relative;
  flex: 1;
  max-width: 400px;
}
.book-search-box {
  position: relative;
  display: flex;
  align-items: center;
  background: rgba(30, 41, 59, 0.4);
  backdrop-filter: blur(8px);
  border: 1px solid rgba(148, 163, 184, 0.3);
  border-radius: 8px;
  padding: 0.5rem 0.75rem;
  transition: all 0.3s ease;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
}
.book-search-box:focus-within {
  border-color: rgba(59, 130, 246, 0.6);
  background: rgba(30, 41, 59, 0.6);
  box-shadow: 0 4px 12px rgba(59, 130, 246, 0.2);
}
.book-search-box .search-icon {
  color: #94a3b8;
  margin-right: 0.5rem;
  flex-shrink: 0;
}
.book-search-box input {
  flex: 1;
  background: transparent;
  border: none;
  outline: none;
  color: #e2e8f0;
  font-size: 0.9rem;
  padding: 0;
}
.book-search-box input::placeholder {
  color: #64748b;
}
.search-clear-btn {
  background: none;
  border: none;
  color: #94a3b8;
  cursor: pointer;
  padding: 0.25rem;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 4px;
  transition: all 0.2s;
}
.search-clear-btn:hover {
  background: rgba(148, 163, 184, 0.2);
  color: #e2e8f0;
}
.book-search-results {
  position: absolute;
  bottom: calc(100% + 0.5rem);
  left: 0;
  right: 0;
  background: rgba(30, 41, 59, 0.98);
  border: 1px solid rgba(148, 163, 184, 0.3);
  border-radius: 8px;
  max-height: 300px;
  overflow-y: auto;
  z-index: 1000;
  box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
}
.search-result-item {
  padding: 0.75rem;
  border-bottom: 1px solid rgba(148, 163, 184, 0.2);
  cursor: pointer;
  transition: background 0.2s;
}
.search-result-item:last-child {
  border-bottom: none;
}
.search-result-item:hover {
  background: rgba(59, 130, 246, 0.2);
}
.search-result-page {
  font-size: 0.75rem;
  color: #3b82f6;
  font-weight: 600;
  margin-bottom: 0.25rem;
}
.search-result-content {
  font-size: 0.85rem;
  color: #e2e8f0;
  line-height: 1.4;
}
.search-result-content mark {
  background: rgba(59, 130, 246, 0.3);
  color: #60a5fa;
  padding: 0 2px;
  border-radius: 2px;
}
.search-no-results {
  padding: 1rem;
  text-align: center;
  color: #94a3b8;
  font-size: 0.9rem;
}

/* Highlight Popover */
#highlight-popover {
    position: fixed;
    background-color: #333;
    border-radius: 6px;
    padding: 4px;
    display: none;
    gap: 4px;
    z-index: 1000;
    box-shadow: 0 4px 12px rgba(0,0,0,0.4);
}
#highlight-popover button {
    background: none;
    border: 1px solid #555;
    color: white;
    border-radius: 4px;
    padding: 4px 8px;
    cursor: pointer;
    font-size: 0.8rem;
}
#highlight-popover button:hover {
    background: #555;
}

/* Generic Modal Styles */
.modal-overlay {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.7);
    z-index: 1000;
    display: none;
}
.modal {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: hsl(var(--card));
    color: hsl(var(--card-foreground));
    padding: 2rem;
    border-radius: 8px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.5);
    z-index: 1001;
    width: 350px;
    display: none;
    box-sizing: border-box;
}
.modal h3 {
    margin-top: 0;
}
.modal label {
    display: block;
    margin-top: 1rem;
    color: hsl(var(--muted-foreground));
    font-size: 0.9rem;
}
.modal input[type="text"],
.modal input[type="number"],
.modal input[type="color"],
.modal textarea {
    width: 100%;
    background-color: hsl(var(--background));
    color: hsl(var(--foreground));
    border: 1px solid hsl(var(--border));
    border-radius: 4px;
    padding: 8px;
    margin-top: 0.5rem;
    box-sizing: border-box;
}
.modal-buttons {
    margin-top: 1.5rem;
    display: flex;
    justify-content: flex-end;
    gap: 1rem;
}

/* Highlight Modal Specifics */
#highlight-modal textarea {
    min-height: 80px;
}
.color-picker {
    display: flex;
    gap: 10px;
    margin-top: 1rem;
}
.color-box {
    width: 30px;
    height: 30px;
    border-radius: 50%;
    cursor: pointer;
    border: 2px solid transparent;
    transition: border-color 0.2s;
}
.color-box.selected {
    border-color: hsl(var(--foreground));
}

/* Book Settings Modal */
.modal-large {
    width: 600px !important;
    max-width: 95vw;
}

.modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1.5rem;
    padding-bottom: 1rem;
    border-bottom: 1px solid rgba(148, 163, 184, 0.2);
}

.modal-header h2 {
    margin: 0;
    font-size: 1.5rem;
    color: #e2e8f0;
}

.modal-close {
    background: none;
    border: none;
    color: #94a3b8;
    font-size: 2rem;
    cursor: pointer;
    padding: 0;
    width: 32px;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 8px;
    transition: all 0.2s;
}

.modal-close:hover {
    background: rgba(148, 163, 184, 0.15);
    color: #e2e8f0;
}

.book-settings-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 2rem;
}

.book-settings-preview {
    display: flex;
    flex-direction: column;
    gap: 1rem;
}

.settings-preview-card {
    background: rgba(15, 23, 42, 0.6);
    border: 1px solid rgba(148, 163, 184, 0.2);
    border-radius: 12px;
    padding: 1.25rem;
    display: flex;
    flex-direction: column;
    gap: 1rem;
}

.settings-preview-author {
    color: #94a3b8;
    font-size: 0.9rem;
    font-weight: 500;
    padding-bottom: 0.75rem;
    border-bottom: 1px solid rgba(148, 163, 184, 0.2);
}

.settings-preview-cover {
    width: 100%;
    height: 220px;
    border-radius: 12px;
    overflow: hidden;
    background: rgba(15, 23, 42, 0.6);
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
}

.settings-preview-placeholder {
    font-size: 5rem;
    opacity: 0.3;
}

.settings-preview-cover img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    position: absolute;
    top: 0;
    left: 0;
}

.settings-preview-info {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
}

.settings-preview-info h4 {
    margin: 0;
    font-size: 1.25rem;
    color: #e2e8f0;
}

.settings-preview-info p {
    margin: 0;
    color: #cbd5e1;
    font-size: 0.9rem;
    line-height: 1.5;
}

.color-picker-container {
    display: flex;
    gap: 0.75rem;
    align-items: center;
}

.color-picker-container input[type="color"] {
    width: 60px;
    height: 40px;
    border: 1px solid rgba(148, 163, 184, 0.3);
    border-radius: 8px;
    cursor: pointer;
    background: transparent;
    padding: 2px;
}

.color-picker-container input[type="text"] {
    flex: 1;
    font-family: 'Courier New', monospace;
    text-transform: uppercase;
}

@media (max-width: 768px) {
    .modal-large {
        width: 95vw !important;
        max-width: 500px;
        max-height: 70vh;
    }
    
    .modal-content {
        max-height: 70vh;
        overflow-y: auto;
        padding: 1.5rem;
    }
    
    /* 2-column layout for form fields on mobile */
    #book-settings-form {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 1rem;
        column-gap: 1.5rem;
    }
    
    #book-settings-form label {
        margin-bottom: 0;
    }
    
    /* Full width for some fields */
    #book-settings-form label:has(textarea),
    #book-settings-form label:has([name="cover_url"]),
    #book-settings-form label:has([type="checkbox"]),
    #book-settings-form .form-actions {
        grid-column: 1 / -1;
    }
    
    #book-settings-form textarea {
        rows: 2;
        min-height: 60px;
    }
    
    .book-settings-grid {
        grid-template-columns: 1fr;
    }
    
    .settings-preview-cover {
        height: 160px;
    }
    
    .modal-header h2 {
        font-size: 1.25rem;
    }
    
    .book-settings-form label {
        margin-bottom: 0.75rem;
    }
    
    form textarea {
        min-height: 60px;
    }
    
    .book-search-container {
        max-width: 250px;
    }
    
    .book-search-box {
        padding: 0.4rem 0.6rem;
    }
    
    .book-search-box input {
        font-size: 0.85rem;
    }
    
    .book-search-box .search-icon {
        width: 16px;
        height: 16px;
    }
}
/* Mobile Components */
.mobile-top-bar {
  display: none; /* Hidden by default on desktop */
}

.search-container-mobile {
  display: none; /* Hidden by default */
  position: relative;
  flex: 1;
}

.mobile-menu-btn {
  background: rgba(30, 41, 59, 0.4);
  backdrop-filter: blur(8px);
  border: 1px solid rgba(148, 163, 184, 0.3);
  border-radius: 8px;
  padding: 0.5rem;
  color: #e2e8f0;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.3s ease;
}

.mobile-menu-btn:hover {
  background: rgba(30, 41, 59, 0.6);
  border-color: rgba(59, 130, 246, 0.5);
}

.mobile-menu-dropdown {
  position: absolute;
  top: calc(100% + 0.5rem);
  left: 0;
  background: rgba(30, 41, 59, 0.98);
  border: 1px solid rgba(148, 163, 184, 0.3);
  border-radius: 8px;
  min-width: 200px;
  box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
  z-index: 1000;
}

.mobile-menu-item {
  width: 100%;
  padding: 0.75rem 1rem;
  background: transparent;
  border: none;
  color: #e2e8f0;
  text-align: left;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 0.5rem;
  font-size: 0.9rem;
  transition: background 0.2s;
  border-bottom: 1px solid rgba(148, 163, 184, 0.2);
}

.mobile-menu-item:last-child {
  border-bottom: none;
}

.mobile-menu-item:hover {
  background: rgba(59, 130, 246, 0.1);
}

.mobile-toolbar-container {
  display: none; /* Hidden by default on desktop */
}

.mobile-toolbar-toggle {
  width: 100%;
  padding: 0.75rem;
  background: rgba(30, 41, 59, 0.4);
  backdrop-filter: blur(8px);
  border: 1px solid rgba(148, 163, 184, 0.3);
  border-radius: 8px;
  color: #e2e8f0;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 0.5rem;
  font-size: 0.9rem;
  transition: all 0.3s ease;
}

.mobile-toolbar-toggle:hover {
  background: rgba(30, 41, 59, 0.6);
  border-color: rgba(59, 130, 246, 0.5);
}

.mobile-search-box {
  position: relative;
  display: flex;
  align-items: center;
  gap: 0.5rem;
  flex: 1;
}

.mobile-search-box input {
  flex: 1;
  background: rgba(30, 41, 59, 0.4);
  backdrop-filter: blur(8px);
  border: 1px solid rgba(148, 163, 184, 0.3);
  border-radius: 8px;
  padding: 0.5rem 2.5rem 0.5rem 0.75rem;
  outline: none;
  color: #e2e8f0;
  font-size: 0.9rem;
  transition: all 0.3s ease;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
}

.mobile-search-box input:focus {
  border-color: rgba(59, 130, 246, 0.6);
  background: rgba(30, 41, 59, 0.6);
  box-shadow: 0 4px 12px rgba(59, 130, 246, 0.2);
}

.mobile-search-box input::placeholder {
  color: #94a3b8;
}

.mobile-search-box button {
  position: absolute;
  right: 0.5rem;
  background: transparent;
  border: none;
  color: #94a3b8;
  cursor: pointer;
  padding: 0.25rem;
  display: flex;
  align-items: center;
  justify-content: center;
}

.mobile-search-box button:hover {
  color: #e2e8f0;
}

.mobile-search-results {
  position: absolute;
  top: calc(100% + 0.5rem);
  left: 0;
  right: 0;
  background: rgba(30, 41, 59, 0.98);
  border: 1px solid rgba(148, 163, 184, 0.3);
  border-radius: 8px;
  max-height: 300px;
  overflow-y: auto;
  z-index: 1000;
  box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
  display: none;
}

.mobile-search-results .search-result-item {
  padding: 0.75rem;
  border-bottom: 1px solid rgba(148, 163, 184, 0.2);
  cursor: pointer;
  transition: background 0.2s;
}

.mobile-search-results .search-result-item:last-child {
  border-bottom: none;
}

.mobile-search-results .search-result-item:hover {
  background: rgba(59, 130, 246, 0.1);
}

.mobile-search-results .search-result-page {
  color: #3b82f6;
  font-weight: 600;
  font-size: 0.85rem;
  margin-bottom: 0.25rem;
}

.mobile-search-results .search-result-content {
  color: #cbd5e1;
  font-size: 0.85rem;
  line-height: 1.4;
  font-family: 'Courier New', monospace;
}

.search-result-content::first-letter {
  font-weight: bold;
}

.mobile-search-results .search-result-content mark {
  background: rgba(59, 130, 246, 0.3);
  color: #60a5fa;
  padding: 0.1rem 0.2rem;
  border-radius: 2px;
}

.mobile-search-results .search-no-results {
  padding: 1rem;
  text-align: center;
  color: #94a3b8;
  font-size: 0.9rem;
}
#loader {
    font-size: 1.5rem;
    color: hsl(var(--foreground));
}
  @media (max-width: 767px) {
  .pageflipper-container {
    padding: 0;
    padding-top: 4.5rem; /* Space for mobile top bar - overlap a bit */
  }

  /* Hide desktop controls */
  .controls {
    display: none;
  }
  
  /* Show mobile top bar */
  .mobile-top-bar {
    display: flex;
    position: fixed;
    top: 3rem;
    left: 1rem;
    right: 1rem;
    z-index: 200;
    gap: 0.5rem;
    align-items: flex-start;
  }
  
  /* Mobile search */
  .search-container-mobile {
    display: block;
    flex: 1;
  }
  
  /* Show mobile toolbar container */
  .mobile-toolbar-container {
    display: block;
    position: fixed;
    bottom: 1rem;
    left: 1rem;
    right: 1rem;
    z-index: 100;
  }
  
  /* Editor toolbar on mobile - dropup from bottom */
  .editor-toolbar {
    position: fixed;
    bottom: 4.5rem;
    left: 1rem;
    right: 1rem;
    width: auto;
    max-width: none;
    z-index: 99;
    background: rgba(30, 41, 59, 0.98);
    border: 1px solid rgba(148, 163, 184, 0.3);
    border-radius: 8px;
    padding: 0.5rem;
    box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
    display: flex; /* Always flex for animation */
    flex-wrap: wrap;
    justify-content: center;
    gap: 0.25rem;
    transform: translateY(calc(100% + 5rem));
    opacity: 0;
    pointer-events: none;
    transition: transform 0.3s ease, opacity 0.3s ease;
  }
  
  .editor-toolbar.active {
    transform: translateY(0);
    opacity: 1;
    pointer-events: auto;
  }
  
  .editor-toolbar .toolbar-button {
    padding: 0.5rem;
  }

  /* Convert the book to a horizontal scroll container */
  .book-container {
    display: flex;
    overflow-x: auto;
    overflow-y: hidden; /* Keep horizontal scroll only */
    scroll-snap-type: x mandatory;
    -webkit-overflow-scrolling: touch;
    perspective: none;
    width: 100vw;
    height: 85vh;
    max-width: none;
    max-height: none;
    position: static;
    box-shadow: none;
    transform: none !important; /* Override hover/closed transforms */
  }

  /* Each sheet becomes a full-width page container */
  .sheet {
    position: relative;
    left: 0;
    top: 0;
    width: 200%;
    height: 100%;
    transform-style: flat;
    transform: none !important;
    box-shadow: none;
    display: flex; /* Make it a flex container for its children */
    flex-shrink: 0;
    overflow: visible; /* Allow page overflow */
  }

  /* Each page becomes a scroll-snap item */
  .page {
    position: relative; /* Change from absolute */
    flex-shrink: 0;
    width: 50%;
    height: 100%; /* Fixed height */
    scroll-snap-align: center;
    border-radius: 0 !important;
    transform: none !important; /* Override backface transform */
    backface-visibility: visible;
    border-left: none;
    border-right: none;
    display: flex !important;
    flex-direction: column;
    overflow-y: auto; /* Page itself scrolls vertically */
    -webkit-overflow-scrolling: touch;
    box-sizing: border-box;
    pointer-events: auto !important; /* Reset pointer-events for mobile */
  }
  
  /* Reset pointer-events for mobile sheets */
  .sheet .page-back,
  .sheet .page-front {
    pointer-events: auto !important;
  }
  
  .page-content {
    padding: 1.5rem 1rem;
    flex: 0 0 auto; /* Don't grow, natural height */
    min-height: min-content;
  }
  
  /* Keep editable-area scrollable on mobile like desktop */
  .editable-area {
    overflow-y: auto !important;
    overflow-x: hidden !important;
    -webkit-overflow-scrolling: touch;
    flex: 1; /* Take remaining space in page */
    min-height: 200px; /* Minimum height for content */
  }

  .page-number-left, .page-number-right {
    bottom: 0.5rem;
    background: hsla(var(--background), 0.7);
    padding: 0.2rem 0.4rem;
    border-radius: 4px;
  }
  .page-number-left { left: 0.5rem; }
  .page-number-right { right: 0.5rem; }
}
</style>
<link rel="preconnect" href="https://fonts.googleapis.com" />
<link rel="preconnect" href="https://fonts.gstatic.com" crossOrigin="anonymous" />
<link href="https://fonts.googleapis.com/css2?family=Literata:ital,opsz,wght@0,7..72,400;0,7..72,700;1,7..72,400;1,7..72,700&display=swap" rel="stylesheet" />
</head>
<body>
<main>
<div id="loader">Loading your book...</div>
<div class="pageflipper-container" style="display: none;">
  <div class="editor-toolbar">
    <button id="bold-btn" class="toolbar-button" title="Bold (Ctrl+B)">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 4h8a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"></path><path d="M6 12h9a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"></path></svg>
    </button>
    <button id="italic-btn" class="toolbar-button" title="Italic (Ctrl+I)">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="19" y1="4" x2="10" y2="4"></line><line x1="14" y1="20" x2="5" y2="20"></line><line x1="15" y1="4" x2="9" y2="20"></line></svg>
    </button>
    <button id="underline-btn" class="toolbar-button" title="Underline (Ctrl+U)">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 3v7a6 6 0 0 0 6 6 6 6 0 0 0 6-6V3"></path><line x1="4" y1="21" x2="20" y2="21"></line></svg>
    </button>
    <button id="image-btn" class="toolbar-button" title="Insert Image">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0-0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>
    </button>
    <button id="fontsize-btn" class="toolbar-button" title="C·ª° ch·ªØ">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="4 7 4 4 7 4"></polyline><polyline points="20 7 20 4 17 4"></polyline><polyline points="14 20 14 17 17 17"></polyline><polyline points="10 20 10 17 7 17"></polyline><line x1="7" y1="12" x2="17" y2="12"></line></svg>
    </button>
    <button id="fontcolor-btn" class="toolbar-button" title="M√†u ch·ªØ">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 14c-2.5 0-4.5-2-4.5-4.5S9.5 5 12 5s4.5 2 4.5 4.5-2 4.5-4.5 4.5zm0-2c-1.38 0-2.5-1.12-2.5-2.5S10.62 7 12 7s2.5 1.12 2.5 2.5S13.38 12 12 12zm0 8c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm0-14c-3.31 0-6 2.69-6 6s2.69 6 6 6 6-2.69 6-6-2.69-6-6-6z"/><path d="M20.71 14.71l-1.42 1.42c-.39.39-1.02.39-1.41 0l-1.17-1.17c-.39-.39-.39-1.02 0-1.41l1.42-1.42c.39-.39 1.02-.39 1.41 0l1.17 1.17c.39.39.39 1.02 0 1.41z"/></svg>
    </button>
    <button id="table-btn" class="toolbar-button" title="Insert Table">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="3" y1="9" x2="21" y2="9"></line><line x1="3" y1="15" x2="21" y2="15"></line><line x1="9" y1="3" x2="9" y2="21"></line><line x1="15" y1="3" x2="15" y2="21"></line></svg>
    </button>
    <input type="file" id="image-upload" accept="image/*" style="display: none;" />
  </div>
  <!-- Mobile Top Bar -->
  <div class="mobile-top-bar">
    <!-- Hamburger Menu Button - Only for Author, Left-most -->
    {{if .IsAuthor}}
    <button id="mobile-menu-btn" class="mobile-menu-btn">
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <line x1="3" y1="12" x2="21" y2="12"></line>
        <line x1="3" y1="6" x2="21" y2="6"></line>
        <line x1="3" y1="18" x2="21" y2="18"></line>
      </svg>
    </button>
    
    <!-- Mobile Menu Dropdown -->
    <div id="mobile-menu-dropdown" class="mobile-menu-dropdown" style="display: none;">
      <button id="mobile-settings-btn" class="mobile-menu-item">
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M12 1v6m0 6v6m-6-6h6m6 0h6"></path></svg>
        C√†i ƒë·∫∑t s√°ch
      </button>
      <button id="mobile-add-page-btn" class="mobile-menu-item">
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>
        Th√™m trang
      </button>
      
      <!-- Divider -->
      <div style="border-top: 1px solid rgba(148, 163, 184, 0.3); margin: 0.5rem 0;"></div>
      
      <!-- Toolbar Buttons -->
      <button id="mobile-bold-btn" class="mobile-menu-item toolbar-action">
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 4h8a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"></path><path d="M6 12h9a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"></path></svg>
        Bold
      </button>
      <button id="mobile-italic-btn" class="mobile-menu-item toolbar-action">
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="19" y1="4" x2="10" y2="4"></line><line x1="14" y1="20" x2="5" y2="20"></line><line x1="15" y1="4" x2="9" y2="20"></line></svg>
        Italic
      </button>
      <button id="mobile-underline-btn" class="mobile-menu-item toolbar-action">
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 3v7a6 6 0 0 0 6 6 6 6 0 0 0 6-6V3"></path><line x1="4" y1="21" x2="20" y2="21"></line></svg>
        Underline
      </button>
      <button id="mobile-image-btn" class="mobile-menu-item toolbar-action">
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>
        Ch√®n ·∫£nh
      </button>
      <button id="mobile-fontsize-btn" class="mobile-menu-item toolbar-action">
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="4 7 4 4 7 4"></polyline><polyline points="20 7 20 4 17 4"></polyline><polyline points="14 20 14 17 17 17"></polyline><polyline points="10 20 10 17 7 17"></polyline><line x1="7" y1="12" x2="17" y2="12"></line></svg>
        C·ª° ch·ªØ
      </button>
      <button id="mobile-fontcolor-btn" class="mobile-menu-item toolbar-action">
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 14c-2.5 0-4.5-2-4.5-4.5S9.5 5 12 5s4.5 2 4.5 4.5-2 4.5-4.5 4.5zm0-2c-1.38 0-2.5-1.12-2.5-2.5S10.62 7 12 7s2.5 1.12 2.5 2.5S13.38 12 12 12zm0 8c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm0-14c-3.31 0-6 2.69-6 6s2.69 6 6 6 6-2.69 6-6-2.69-6-6-6z"/><path d="M20.71 14.71l-1.42 1.42c-.39.39-1.02.39-1.41 0l-1.17-1.17c-.39-.39-.39-1.02 0-1.41l1.42-1.42c.39-.39 1.02-.39 1.41 0l1.17 1.17c.39.39.39 1.02 0 1.41z"/></svg>
        M√†u ch·ªØ
      </button>
      <button id="mobile-table-btn" class="mobile-menu-item toolbar-action">
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="3" y1="9" x2="21" y2="9"></line><line x1="3" y1="15" x2="21" y2="15"></line><line x1="9" y1="3" x2="9" y2="21"></line><line x1="15" y1="3" x2="15" y2="21"></line></svg>
        T·∫°o b·∫£ng
      </button>
    </div>
    {{end}}
    
    <div class="search-container-mobile">
      <div class="mobile-search-box">
        <input type="text" id="mobile-search-input" placeholder="T√¨m trong s√°ch..." autocomplete="off" />
        <button id="mobile-search-clear" class="search-clear-btn" style="display: none;">
          <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
          </svg>
        </button>
      </div>
      <div id="mobile-search-results" class="mobile-search-results"></div>
    </div>
  </div>
  <div id="book-container" class="book-container">
    <!-- Sheets will be generated here by JavaScript -->
  </div>
  <div class="controls">
    <div class="nav-buttons">
      <button id="prev-btn" class="button">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m12 19-7-7 7-7"/><path d="M19 12H5"/></svg>
        Trang tr∆∞·ªõc
      </button>
      
      <!-- Search Box -->
      <div class="book-search-container">
        <div class="book-search-box">
          <svg class="search-icon" xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="11" cy="11" r="8"></circle>
            <path d="m21 21-4.35-4.35"></path>
          </svg>
          <input
            type="text"
            id="book-search-input"
            placeholder="T√¨m trong s√°ch..."
            autocomplete="off"
          />
          <button id="book-search-clear" class="search-clear-btn" style="display: none;">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <line x1="18" y1="6" x2="6" y2="18"></line>
              <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
          </button>
        </div>
        <div id="book-search-results" class="book-search-results" style="display: none;"></div>
      </div>
      
      <button id="next-btn" class="button">
        Trang sau
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M5 12h14"/><path d="m12 5 7 7-7 7"/></svg>
      </button>
    </div>

    {{if .IsAuthor}}
    <button id="book-settings-btn" class="button">
      ‚öôÔ∏è C√†i ƒë·∫∑t s√°ch
    </button>
    {{end}}

    <button id="add-page-btn" class="button icon-button">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>
    </button>
  </div>
</div>
</main>

<!-- Highlight Popover -->
<div id="highlight-popover">
<button id="popover-highlight-btn">Highlight</button>
<button id="popover-remove-highlight-btn">X√≥a highlight</button>
</div>

<!-- Highlight Modal -->
<div id="highlight-modal-overlay" class="modal-overlay"></div>
<div id="highlight-modal" class="modal">
  <h3>Th√™m ch√∫ th√≠ch</h3>
  <textarea id="highlight-note-input" placeholder="Enter your explanation here..."></textarea>
  
  <h3>Ch·ªçn m√†u</h3>
  <div class="color-picker">
      <div class="color-box selected" style="background-color: var(--highlight-yellow);" data-color="var(--highlight-yellow)"></div>
      <div class="color-box" style="background-color: var(--highlight-pink);" data-color="var(--highlight-pink)"></div>
      <div class="color-box" style="background-color: var(--highlight-blue);" data-color="var(--highlight-blue)"></div>
      <div class="color-box" style="background-color: var(--highlight-green);" data-color="var(--highlight-green)"></div>
  </div>
  
  <div class="modal-buttons">
      <button id="highlight-modal-cancel-btn" class="button" style="background-color: hsl(var(--border)); color: hsl(var(--foreground));">H·ªßy</button>
      <button id="highlight-modal-remove-btn" class="button" style="background-color: #ef4444; color: white; display: none;">X√≥a m√†u</button>
      <button id="highlight-modal-save-btn" class="button">L∆∞u</button>
  </div>
</div>

<!-- Generic Input Modal -->
<div id="input-modal-overlay" class="modal-overlay"></div>
<div id="input-modal" class="modal">
  <h3 id="input-modal-title">Nh·∫≠p gi√° tr·ªã</h3>
  <div id="input-modal-content"></div>
  <div class="modal-buttons">
      <button id="input-modal-cancel-btn" class="button" style="background-color: hsl(var(--border)); color: hsl(var(--foreground));">Cancel</button>
      <button id="input-modal-save-btn" class="button">OK</button>
  </div>
</div>

<!-- Book Settings Modal -->
{{if .IsAuthor}}
<div id="book-settings-modal" class="modal" style="display: none;">
  <div class="modal-content modal-large">
      <div class="modal-header">
          <h2>‚öôÔ∏è C√†i ƒë·∫∑t s√°ch</h2>
          <button type="button" class="modal-close" data-action="close-book-settings">√ó</button>
      </div>
      <form id="book-settings-form" class="stack">
          <label>
              Ti√™u ƒë·ªÅ s√°ch
              <input type="text" name="title" value="{{.Book.Title}}" placeholder="Nh·∫≠p ti√™u ƒë·ªÅ s√°ch" required>
          </label>
          <label>
              M√¥ t·∫£ ng·∫Øn
              <textarea name="description" rows="4" placeholder="T√≥m t·∫Øt n·ªôi dung s√°ch...">{{.Book.Description}}</textarea>
          </label>
          <label>
              ·∫¢nh b√¨a (URL)
              <input type="url" name="cover_url" value="{{.Book.CoverURL}}" placeholder="https://example.com/cover.jpg">
              <small style="color: #94a3b8; font-size: 0.85rem;">ƒê·ªÉ tr·ªëng n·∫øu mu·ªën d√πng m√†u n·ªÅn</small>
          </label>
          <label>
              M√†u b√¨a s√°ch
              <div class="color-picker-container">
                  <input type="color" name="cover_color" value="{{if .Book.CoverColor}}{{.Book.CoverColor}}{{else}}#1e293b{{end}}">
                  <input type="text" value="{{if .Book.CoverColor}}{{.Book.CoverColor}}{{else}}#1e293b{{end}}" placeholder="#1e293b" pattern="^#[0-9A-Fa-f]{6}$">
              </div>
              <small style="color: #94a3b8; font-size: 0.85rem;">Ch·ªçn m√†u n·ªÅn cho b√¨a s√°ch khi kh√¥ng c√≥ ·∫£nh</small>
          </label>
          <label>
              Tag s√°ch
              <input type="text" name="book_tag" value="{{.Book.BookTag}}" placeholder="linux, golang, devops..." maxlength="50">
              <small style="color: #94a3b8; font-size: 0.85rem;">Tag ch√≠nh c·ªßa s√°ch (hi·ªÉn th·ªã d·∫°ng @tag ·ªü g√≥c b√¨a)</small>
          </label>
          <label>
              Danh m·ª•c
              <input type="text" name="book_category" value="{{.Book.BookCategory}}" placeholder="L·∫≠p tr√¨nh, H·ªá ƒëi·ªÅu h√†nh..." maxlength="50">
              <small style="color: #94a3b8; font-size: 0.85rem;">Danh m·ª•c ƒë·ªÉ ph√¢n lo·∫°i v√† l·ªçc s√°ch</small>
          </label>
          <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
              <input type="checkbox" name="published" {{if .Book.Published}}checked{{end}} style="cursor: pointer;">
              <span>Xu·∫•t b·∫£n s√°ch (cho ph√©p ng∆∞·ªùi kh√°c xem)</span>
          </label>
          <div class="form-actions">
              <button type="button" class="btn ghost" data-action="cancel-book-settings">H·ªßy</button>
              <button type="submit" class="btn primary">üíæ L∆∞u thay ƒë·ªïi</button>
          </div>
      </form>
  </div>
</div>
{{end}}


<script>
document.addEventListener('DOMContentLoaded', () => {
  // --- CONFIGURATION ---
  function getBookIdFromUrl() {
      // URL format: /books/:id/read
      const pathParts = window.location.pathname.split('/').filter(p => p);
      if (pathParts[0] === 'books' && pathParts.length >= 3 && pathParts[2] === 'read') {
          const bookId = pathParts[1];
          if (bookId && !isNaN(parseInt(bookId, 10))) {
              return parseInt(bookId, 10);
          }
      }
      console.warn("Could not find book ID in URL, falling back to 1. URL should be like /books/1/read");
      return 1; 
  }
  const BOOK_ID = getBookIdFromUrl();

  const FLIP_DURATION = 500;
  const DEBOUNCE_DELAY = 1500; // ms to wait after user stops typing to save

  // --- STATE ---
  let book = null; // { id, title, pages: [...] }
  let currentSpread = 0;
  let isFlipping = false;
  let currentSelection = null;
  let activeEditableArea = null;
  let selectedImage = null;
  let debounceTimeout = null;
  let isAuthenticated = false; // Track if user is logged in
  let isAuthor = false; // Track if user is the book author
  let currentUserId = 0; // Current logged in user ID
  let authorId = 0; // Book author ID

  // --- DOM ELEMENTS ---
  const loader = document.getElementById('loader');
  const pageFlipperContainer = document.querySelector('.pageflipper-container');
  const bookContainer = document.getElementById('book-container');
  const prevBtn = document.getElementById('prev-btn');
  const nextBtn = document.getElementById('next-btn');
  const addPageBtn = document.getElementById('add-page-btn');
  const editorToolbar = document.querySelector('.editor-toolbar');
  
  // Search elements (Desktop)
  const bookSearchInput = document.getElementById('book-search-input');
  const bookSearchClear = document.getElementById('book-search-clear');
  const bookSearchResults = document.getElementById('book-search-results');
  
  // Search elements (Mobile)
  const mobileSearchInput = document.getElementById('mobile-search-input');
  const mobileSearchClear = document.getElementById('mobile-search-clear');
  const mobileSearchResults = document.getElementById('mobile-search-results');
  
  // Popovers and Modals
  const highlightPopover = document.getElementById('highlight-popover');
  const popoverHighlightBtn = document.getElementById('popover-highlight-btn');
  const popoverRemoveHighlightBtn = document.getElementById('popover-remove-highlight-btn');
  const highlightModalOverlay = document.getElementById('highlight-modal-overlay');
  const highlightModal = document.getElementById('highlight-modal');
  const noteInput = document.getElementById('highlight-note-input');
  const colorPicker = document.querySelector('.color-picker');
  const highlightModalCancelBtn = document.getElementById('highlight-modal-cancel-btn');
  const highlightModalRemoveBtn = document.getElementById('highlight-modal-remove-btn');
  const highlightModalSaveBtn = document.getElementById('highlight-modal-save-btn');
  const inputModalOverlay = document.getElementById('input-modal-overlay');
  const inputModal = document.getElementById('input-modal');
  const inputModalTitle = document.getElementById('input-modal-title');
  const inputModalContent = document.getElementById('input-modal-content');
  const inputModalCancelBtn = document.getElementById('input-modal-cancel-btn');
  const inputModalSaveBtn = document.getElementById('input-modal-save-btn');
  let inputModalCallback = null;

  // Toolbar
  const boldBtn = document.getElementById('bold-btn');
  const italicBtn = document.getElementById('italic-btn');
  const underlineBtn = document.getElementById('underline-btn');
  const imageBtn = document.getElementById('image-btn');
  const imageUpload = document.getElementById('image-upload');
  const fontsizeBtn = document.getElementById('fontsize-btn');
  const fontcolorBtn = document.getElementById('fontcolor-btn');
  const tableBtn = document.getElementById('table-btn');

  // --- API FUNCTIONS ---
  async function fetchBook() {
    try {
      const response = await fetch(`/books/${BOOK_ID}/read`, {
        headers: {
          'Accept': 'application/json'
        }
      });
      if (!response.ok) {
        let errorDetails = `HTTP error! status: ${response.status}`;
        try {
            const errorJson = await response.clone().json();
            errorDetails = errorJson.error || JSON.stringify(errorJson);
        } catch (e) {
              const text = await response.clone().text();
              errorDetails += ' - Response is not valid JSON: ' + text.substring(0, 200);
        }
        throw new Error(errorDetails);
      }
      book = await response.json();
      if (!book.pages) {
        book.pages = [];
      }
      book.pages.sort((a, b) => a.page_number - b.page_number);
      
      // Check if user is authenticated and if they are the author
      isAuthenticated = book.is_authenticated || false;
      isAuthor = book.is_author || false;
      currentUserId = book.current_user_id || 0;
      authorId = book.author_id || 0;
      
      console.log('User info - isAuth:', isAuthenticated, 'isAuthor:', isAuthor, 'currentUserId:', currentUserId, 'authorId:', authorId);
      
      // Hide editor toolbar and add page button if not author
      // Note: isAuthenticated is for highlights, isAuthor is for editing
      if (!isAuthor) {
          addPageBtn.style.display = 'none';
          editorToolbar.style.display = 'none';
      }
      
      loader.style.display = 'none';
      pageFlipperContainer.style.display = 'flex';
      await renderBook();
    } catch (error) {
      console.error("Failed to load book:", error);
      loader.textContent = `Error loading book. Please check if the backend is running. Details: ${error.message}`;
    }
  }

  async function updatePage(pageId, pageData) {
    try {
      const response = await fetch(`/books/${BOOK_ID}/pages/${pageId}/edit`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(pageData)
      });
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      console.log(`Page ${pageId} updated successfully.`);
    } catch(error) {
      console.error(`Failed to update page ${pageId}:`, error);
    }
  }
  
  async function createPage(pageData) {
      try {
          const response = await fetch(`/books/${BOOK_ID}/pages`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(pageData)
          });
          if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
          const newPage = await response.json();
          console.log("New page created:", newPage);
          return newPage;
      } catch(error) {
          console.error("Failed to create page:", error);
          return null;
      }
  }

  async function saveHighlight(pageId, highlightData) {
      try {
          const response = await fetch(`/books/${BOOK_ID}/pages/${pageId}/highlights`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(highlightData)
          });
          if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
          const highlight = await response.json();
          console.log("Highlight saved:", highlight);
          return highlight;
      } catch(error) {
          console.error("Failed to save highlight:", error);
          return null;
      }
  }

  async function fetchHighlights(pageId) {
      try {
          const response = await fetch(`/books/${BOOK_ID}/pages/${pageId}/highlights`);
          if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
          const highlights = await response.json();
          // Ensure highlights is an array
          const highlightsArray = Array.isArray(highlights) ? highlights : [];
          console.log(`Fetched ${highlightsArray.length} highlights for page ${pageId}:`, highlightsArray);
          return highlightsArray;
      } catch(error) {
          console.error("Failed to fetch highlights:", error);
          return [];
      }
  }

  async function deleteHighlight(pageId, highlightId) {
      try {
          const response = await fetch(`/books/${BOOK_ID}/pages/${pageId}/highlights/${highlightId}`, {
              method: 'DELETE'
          });
          if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
          console.log("Highlight deleted:", highlightId);
          return true;
      } catch(error) {
          console.error("Failed to delete highlight:", error);
          return false;
      }
  }

  // --- CORE LOGIC ---
  async function loadHighlightsForPage(pageId, editableElement) {
      if (pageId === 'cover' || pageId === 'back-cover' || pageId === 'placeholder' || isNaN(parseInt(pageId))) {
          return;
      }

      console.log(`loadHighlightsForPage called for page ${pageId}`);
      
      // First, clear all existing highlights to avoid duplicates
      const existingHighlights = editableElement.querySelectorAll('mark[data-highlight-id]');
      existingHighlights.forEach(mark => {
          // Replace mark with its text content, preserving formatting
          const parent = mark.parentNode;
          while (mark.firstChild) {
              // Remove highlight-note spans
              if (mark.firstChild.classList && mark.firstChild.classList.contains('highlight-note')) {
                  mark.removeChild(mark.firstChild);
              } else {
                  parent.insertBefore(mark.firstChild, mark);
              }
          }
          parent.removeChild(mark);
      });
      
      // Normalize text nodes to merge adjacent text nodes
      editableElement.normalize();
      
      // Try to load highlights (may fail if not authenticated, that's ok)
      let highlights = [];
      try {
          highlights = await fetchHighlights(pageId);
      } catch (error) {
          // Silently fail if not authenticated - highlights just won't show
          console.log("Could not load highlights (may not be authenticated)");
          return;
      }

      if (!highlights || highlights.length === 0) {
          console.log(`No highlights found for page ${pageId}`);
          return;
      }
      
      console.log(`Applying ${highlights.length} highlights to page ${pageId}`);

      // Sort highlights by start_offset ascending to apply from start to end
      highlights.sort((a, b) => a.start_offset - b.start_offset);
      
      // Apply highlights using a more robust method that preserves HTML
      for (const highlight of highlights) {
          try {
              applyHighlightToElement(editableElement, highlight);
          } catch (e) {
              console.error("Error applying highlight:", e, highlight);
          }
      }
  }
  
  // Helper function to apply a single highlight while preserving HTML structure
  function applyHighlightToElement(element, highlight) {
      const range = document.createRange();
      const walker = document.createTreeWalker(
          element,
          NodeFilter.SHOW_TEXT,
          null,
          false
      );
      
      let currentOffset = 0;
      let startNode = null;
      let startOffset = 0;
      let endNode = null;
      let endOffset = 0;
      
      // Find the start and end text nodes
      while (walker.nextNode()) {
          const node = walker.currentNode;
          const nodeLength = node.textContent.length;
          
          if (!startNode && currentOffset + nodeLength > highlight.start_offset) {
              startNode = node;
              startOffset = highlight.start_offset - currentOffset;
          }
          
          if (!endNode && currentOffset + nodeLength >= highlight.end_offset) {
              endNode = node;
              endOffset = highlight.end_offset - currentOffset;
              break;
          }
          
          currentOffset += nodeLength;
      }
      
      if (!startNode || !endNode) {
          console.warn("Could not find text nodes for highlight:", highlight);
          return;
      }
      
      // Create range and extract contents
      range.setStart(startNode, startOffset);
      range.setEnd(endNode, endOffset);
      
      // Create mark element
      const mark = document.createElement('mark');
      mark.style.backgroundColor = highlight.color;
      mark.setAttribute('data-highlight-id', highlight.id);
      
      // Surround the range with the mark element
      try {
          range.surroundContents(mark);
      } catch (e) {
          // If surroundContents fails (e.g., range spans multiple elements),
          // extract contents and wrap them
          const contents = range.extractContents();
          mark.appendChild(contents);
          range.insertNode(mark);
      }
      
      // Add note at the beginning (will be hidden by CSS)
      if (highlight.note) {
          const noteSpan = document.createElement('span');
          noteSpan.className = 'highlight-note';
          noteSpan.textContent = highlight.note;
          // Insert at the beginning of mark
          mark.insertBefore(noteSpan, mark.firstChild);
      }
  }

  function getTextColorForBackground(hexColor) {
      // Convert hex to RGB
      const r = parseInt(hexColor.substr(1, 2), 16);
      const g = parseInt(hexColor.substr(3, 2), 16);
      const b = parseInt(hexColor.substr(5, 2), 16);
      
      // Calculate relative luminance (ITU-R BT.709)
      const luminance = (0.2126 * r + 0.7152 * g + 0.0722 * b) / 255;
      
      // Return black for light backgrounds, white for dark backgrounds
      return luminance > 0.5 ? '#000000' : '#ffffff';
  }

  // Live update cover display without full re-render
  function updateCoverDisplay() {
      const coverPage = document.querySelector('.page.is-cover');
      if (!coverPage) return;
      
      // Update background color
      if (book.cover_color) {
          coverPage.style.backgroundColor = book.cover_color;
          const textColor = getTextColorForBackground(book.cover_color);
          coverPage.style.color = textColor;
          
          // Update overlay
          const overlay = coverPage.querySelector('.cover-color-overlay');
          if (overlay) overlay.style.backgroundColor = book.cover_color;
      }
      
      // Update background image
      let bgImage = coverPage.querySelector('.cover-bg-image');
      if (book.cover_url) {
          if (!bgImage) {
              bgImage = document.createElement('div');
              bgImage.className = 'cover-bg-image';
              const coverContainer = coverPage.querySelector('.cover-container');
              if (coverContainer) {
                  coverContainer.insertBefore(bgImage, coverContainer.firstChild);
              }
          }
          bgImage.style.backgroundImage = `url('${book.cover_url}')`;
      } else if (bgImage) {
          bgImage.remove();
      }
      
      // Update author
      const author = coverPage.querySelector('.cover-author');
      if (author) {
          author.textContent = book.author_name || '·∫®n danh';
          if (book.cover_color) {
              author.style.color = getTextColorForBackground(book.cover_color);
          }
      }
      
      // Update tags (multiple) - now at bottom
      const coverContainer = coverPage.querySelector('.cover-container');
      let tagsContainer = coverPage.querySelector('.cover-tags-container');
      
      if (book.book_tag) {
          const tags = book.book_tag.split(',').map(t => t.trim()).filter(t => t);
          
          if (!tagsContainer) {
              tagsContainer = document.createElement('div');
              tagsContainer.className = 'cover-tags-container';
              if (coverContainer) coverContainer.appendChild(tagsContainer);
          }
          
          // Clear and rebuild tags
          tagsContainer.innerHTML = '';
          tags.forEach(tagText => {
              const tagSpan = document.createElement('span');
              tagSpan.className = 'cover-tag';
              tagSpan.textContent = '@' + tagText;
              if (book.cover_color) {
                  tagSpan.style.color = getTextColorForBackground(book.cover_color);
              }
              tagsContainer.appendChild(tagSpan);
          });
      } else if (tagsContainer) {
          tagsContainer.remove();
      }
      
      // Update category
      let category = coverPage.querySelector('.cover-category');
      if (book.book_category) {
          if (!category) {
              category = document.createElement('div');
              category.className = 'cover-category';
              category.style.position = 'absolute';
              category.style.top = '0.5rem';
              category.style.right = '0.5rem';
              const coverContainer = coverPage.querySelector('.cover-container');
              if (coverContainer) coverContainer.appendChild(category);
          }
          category.textContent = book.book_category;
          if (book.cover_color) {
              category.style.color = getTextColorForBackground(book.cover_color);
          }
      } else if (category) {
          category.remove();
      }
      
      // Update title
      const title = coverPage.querySelector('.cover-title');
      if (title) {
          title.textContent = book.title || 'Book Title';
          if (book.cover_color) {
              title.style.color = getTextColorForBackground(book.cover_color);
          }
      }
      
      // Update description
      let description = coverPage.querySelector('.cover-description');
      if (book.description) {
          if (!description) {
              description = document.createElement('div');
              description.className = 'cover-description';
              const contentCenter = coverPage.querySelector('.cover-content-center');
              if (contentCenter) contentCenter.appendChild(description);
          }
          description.textContent = book.description;
          if (book.cover_color) {
              description.style.color = getTextColorForBackground(book.cover_color);
          }
      } else if (description) {
          description.remove();
      }
  }

  async function renderBook() {
    bookContainer.innerHTML = '';
    if (!book) {
        console.error("Book data is not available for rendering.");
        return;
    }

    // 1. Create a clean array of actual content pages from the API
    const contentPages = book.pages ? [...book.pages] : [];

    // 2. Ensure content pages are even for spread layout
    if (contentPages.length % 2 !== 0) {
        // CREATE A REAL PAGE instead of placeholder
        const lastPageNum = contentPages.length > 0 ? contentPages[contentPages.length - 1].page_number : 0;
        
        // Create the missing page in database
        const newPageData = { page_number: lastPageNum + 1, title: `Page ${lastPageNum + 1}`, content: '' };
        const createdPage = await createPage(newPageData);
        if (createdPage) {
            book.pages.push(createdPage);
            contentPages.push(createdPage);
            console.log("Created missing page to make even layout:", createdPage);
        } else {
            // Fallback to placeholder if creation fails
            contentPages.push({
                id: 'placeholder', 
                page_number: lastPageNum + 1, 
                content: '',
                title: ''
            });
        }
    }
    
    const finalPages = [...contentPages];

    // 3. Add Cover and Back Cover
    // Parse multiple tags
    const tags = book.book_tag ? book.book_tag.split(',').map(t => t.trim()).filter(t => t) : [];
    const tagsHTML = tags.length > 0 ? `
        <div class="cover-tags-container">
            ${tags.map(tag => `<span class="cover-tag">@${tag}</span>`).join('')}
        </div>
    ` : '';
    
    const coverContent = `
        ${book.cover_url ? `<div class="cover-bg-image" style="background-image: url('${book.cover_url}');"></div>` : ''}
        <div class="cover-color-overlay"></div>
        <div class="cover-top-left">
            <div class="cover-author">${book.author_name || '·∫®n danh'}</div>
        </div>
        ${book.book_category ? `<div class="cover-category">${book.book_category}</div>` : ''}
        <div class="cover-content-center">
            <h1 class="cover-title">${book.title || 'Book Title'}</h1>
            ${book.description ? `<div class="cover-description">${book.description}</div>` : ''}
        </div>
        ${tagsHTML}
    `;
    finalPages.unshift({id: 'cover', page_number: 0, content: coverContent});
    
    const quotes = [
        "H·ªçc, h·ªçc n·ªØa, h·ªçc m√£i.", "ƒêi m·ªôt ng√†y ƒë√†ng, h·ªçc m·ªôt s√†ng kh√¥n.",
        "C√≥ c√¥ng m√†i s·∫Øt, c√≥ ng√†y n√™n kim.", "Kh√¥ng th·∫ßy ƒë·ªë m√†y l√†m n√™n.",
        "Mu·ªën bi·∫øt ph·∫£i h·ªèi, mu·ªën gi·ªèi ph·∫£i h·ªçc."
    ];
    const randomQuote = quotes[Math.floor(Math.random() * quotes.length)];
    finalPages.push({id: 'back-cover', page_number: -1, content: randomQuote});

    const numSheets = Math.ceil(finalPages.length / 2);

    for (let index = 0; index < numSheets; index++) {
      const sheet = document.createElement('div');
      const isFlipped = index < currentSpread;
      sheet.className = 'sheet';
      if (isFlipped) {
        sheet.classList.add('flipped');
      }
      // Fix z-index: current spread should be on top
      // Flipped sheets stack from bottom to top (1, 2, 3...)
      // Unflipped sheets stack from top to bottom (numSheets, numSheets-1, ...)
      // Current spread (index === currentSpread) should have highest z-index
      if (index === currentSpread) {
        sheet.style.zIndex = numSheets + 1; // Highest z-index for current spread
      } else if (isFlipped) {
        sheet.style.zIndex = index + 1;
      } else {
        sheet.style.zIndex = numSheets - index;
      }
      
      const frontPageData = finalPages[index * 2];
      const backPageData = finalPages[index * 2 + 1];

      // --- Front Page ---
      if (frontPageData) {
          const pageFront = document.createElement('div');
          const isCover = frontPageData.id === 'cover';
          pageFront.className = 'page page-front';
          if (isCover) {
              pageFront.classList.add('is-cover');
              // Apply cover color if available
              if (book.cover_color) {
                  pageFront.style.backgroundColor = book.cover_color;
                  
                  // Auto text color based on background
                  const textColor = getTextColorForBackground(book.cover_color);
                  pageFront.style.color = textColor;
                  
                  // Apply color to overlay and text elements after they're created
                  setTimeout(() => {
                      const overlay = pageFront.querySelector('.cover-color-overlay');
                      const topLeft = pageFront.querySelector('.cover-top-left');
                      const author = pageFront.querySelector('.cover-author');
                      const tag = pageFront.querySelector('.cover-tag');
                      const category = pageFront.querySelector('.cover-category');
                      const title = pageFront.querySelector('.cover-title');
                      const description = pageFront.querySelector('.cover-description');
                      
                      // Debug positioning hierarchy
                      if (topLeft) {
                          const editableArea = topLeft.closest('.editable-area');
                          const pageContent = topLeft.closest('.page-content');
                          const page = topLeft.closest('.page');
                          
                          console.log('Editable area rect:', editableArea?.getBoundingClientRect());
                          console.log('Page content rect:', pageContent?.getBoundingClientRect());
                          console.log('Page rect:', page?.getBoundingClientRect());
                          
                          topLeft.style.top = '0.5rem';
                          topLeft.style.left = '0.5rem';
                          const rect = topLeft.getBoundingClientRect();
                          console.log('Cover top-left position after fix:', { top: rect.top, left: rect.left });
                      }
                      if (category) {
                          category.style.top = '0.5rem';
                          category.style.right = '0.5rem';
                      }
                      
                      if (overlay) overlay.style.backgroundColor = book.cover_color;
                      if (author) author.style.color = textColor;
                      if (tag) tag.style.color = textColor;
                      if (category) category.style.color = textColor;
                      if (title) title.style.color = textColor;
                      if (description) description.style.color = textColor;
                  }, 0);
              }
          }

          const pageContentFront = document.createElement('div');
          pageContentFront.className = 'page-content';
          
          // Force cover page-content to have no padding/margin
          if (isCover) {
              pageContentFront.style.padding = '0';
              pageContentFront.style.margin = '0';
              pageContentFront.style.display = 'block';
          }
          
          // For cover, add content directly to page-content without editable-area wrapper
          if (isCover) {
              // Create a non-editable div for cover content
              const coverDiv = document.createElement('div');
              coverDiv.className = 'cover-container';
              coverDiv.setAttribute('data-page-id', frontPageData.id);
              coverDiv.innerHTML = frontPageData.content || '';
              coverDiv.style.position = 'absolute';
              coverDiv.style.top = '0';
              coverDiv.style.left = '0';
              coverDiv.style.right = '0';
              coverDiv.style.bottom = '0';
              coverDiv.style.padding = '0';
              coverDiv.style.margin = '0';
              pageContentFront.appendChild(coverDiv);
          } else {
              // Normal pages use editable-area
              const editableFront = document.createElement('div');
              // Always set contentEditable to true to allow text selection
              // But prevent editing for non-authors via event handlers
              editableFront.contentEditable = 'true';
              editableFront.className = 'editable-area';
              editableFront.setAttribute('data-page-id', frontPageData.id);
              editableFront.setAttribute('data-is-author', String(isAuthor));
              editableFront.innerHTML = frontPageData.content || '';
              
              // Debug log
              console.log('Front page created:', {
                pageId: frontPageData.id,
                isAuthor: isAuthor,
                contentEditable: editableFront.contentEditable,
                dataIsAuthor: editableFront.getAttribute('data-is-author')
              });
              
              // Only author can edit content
              if (isAuthor) {
                editableFront.addEventListener('input', handlePageInput);
                editableFront.setAttribute('placeholder', `Start writing on page ${frontPageData.page_number}...`);
              } else {
                // Prevent editing for non-authors while allowing selection
                editableFront.addEventListener('keydown', (e) => {
                  // Allow Ctrl+C, Ctrl+A for copy and select all
                  if (e.ctrlKey && (e.key === 'c' || e.key === 'a')) {
                    return;
                  }
                  e.preventDefault();
                });
                editableFront.addEventListener('paste', (e) => e.preventDefault());
                editableFront.addEventListener('cut', (e) => e.preventDefault());
                editableFront.addEventListener('drop', (e) => e.preventDefault());
              }
              editableFront.addEventListener('focus', () => { activeEditableArea = editableFront; });
              pageContentFront.appendChild(editableFront);
          }

          if(!isCover) {
            const pageNumFront = document.createElement('div');
            pageNumFront.className = 'page-number-right';
            pageNumFront.textContent = frontPageData.page_number;
            pageContentFront.appendChild(pageNumFront);
          }
          pageFront.appendChild(pageContentFront);
          sheet.appendChild(pageFront);
      }
      
      // --- Back Page ---
      if (backPageData) {
          const pageBack = document.createElement('div');
          const isBackCover = backPageData.id === 'back-cover';
          pageBack.className = 'page page-back';
          if (isBackCover) {
              pageBack.classList.add('is-back-cover');
              // Apply cover color to back cover as well
              if (book.cover_color) {
                  pageBack.style.backgroundColor = book.cover_color;
                  
                  // Auto text color based on background
                  const textColor = getTextColorForBackground(book.cover_color);
                  pageBack.style.setProperty('color', textColor, 'important');
                  
                  // Apply to child elements after they're created
                  setTimeout(() => {
                      const editableArea = pageBack.querySelector('.editable-area');
                      if (editableArea) {
                          editableArea.style.setProperty('color', textColor, 'important');
                      }
                  }, 0);
              }
          }

          const pageContentBack = document.createElement('div');
          pageContentBack.className = 'page-content';
          
          const editableBack = document.createElement('div');
          // Always set contentEditable to true to allow text selection
          // But prevent editing for non-authors via event handlers
          const canEdit = isAuthor && !isBackCover && backPageData.id !== 'placeholder';
          editableBack.contentEditable = 'true';
          editableBack.className = 'editable-area';
          editableBack.setAttribute('data-page-id', backPageData.id);
          editableBack.setAttribute('data-is-author', String(canEdit));
          editableBack.innerHTML = backPageData.content || '';
          
          if (!isBackCover && backPageData.id !== 'placeholder') {
            // Only author can edit content
            if (isAuthor) {
              editableBack.addEventListener('input', handlePageInput);
              editableBack.setAttribute('placeholder', `Start writing on page ${backPageData.page_number}...`);
            } else {
              // Prevent editing for non-authors while allowing selection
              editableBack.addEventListener('keydown', (e) => {
                // Allow Ctrl+C, Ctrl+A for copy and select all
                if (e.ctrlKey && (e.key === 'c' || e.key === 'a')) {
                  return;
                }
                e.preventDefault();
              });
              editableBack.addEventListener('paste', (e) => e.preventDefault());
              editableBack.addEventListener('cut', (e) => e.preventDefault());
              editableBack.addEventListener('drop', (e) => e.preventDefault());
            }
            // Don't load highlights immediately - will be loaded when page is visible
          } else {
            // Back cover and placeholder - prevent all editing
            editableBack.addEventListener('keydown', (e) => {
              if (e.ctrlKey && (e.key === 'c' || e.key === 'a')) {
                return;
              }
              e.preventDefault();
            });
            editableBack.addEventListener('paste', (e) => e.preventDefault());
            editableBack.addEventListener('cut', (e) => e.preventDefault());
            editableBack.addEventListener('drop', (e) => e.preventDefault());
          }
          editableBack.addEventListener('focus', () => { activeEditableArea = editableBack; });

          pageContentBack.appendChild(editableBack);
          
          if (!isBackCover && backPageData.page_number > 0) {
              const pageNumBack = document.createElement('div');
              pageNumBack.className = 'page-number-left';
              pageNumBack.textContent = backPageData.page_number;
              pageContentBack.appendChild(pageNumBack);
          }

          pageBack.appendChild(pageContentBack);
          sheet.appendChild(pageBack);
      }
      bookContainer.appendChild(sheet);
    }
    updateButtons();
    
    // Load highlights for visible pages after render
    loadHighlightsForCurrentSpread();
  }
  
  // Load highlights only for currently visible pages
  async function loadHighlightsForCurrentSpread() {
    const currentSheet = bookContainer.children[currentSpread];
    if (!currentSheet) return;
    
    console.log(`Loading highlights for spread ${currentSpread}`);
    const editableAreas = currentSheet.querySelectorAll('.editable-area');
    for (const editableArea of editableAreas) {
      const pageId = editableArea.getAttribute('data-page-id');
      if (pageId && pageId !== 'cover' && pageId !== 'back-cover' && pageId !== 'placeholder' && !isNaN(parseInt(pageId))) {
        // Check if highlights already loaded
        if (!editableArea.hasAttribute('data-highlights-loaded')) {
          console.log(`Loading highlights for page ${pageId}`);
          await loadHighlightsForPage(pageId, editableArea);
          editableArea.setAttribute('data-highlights-loaded', 'true');
        } else {
          console.log(`Highlights already loaded for page ${pageId}`);
        }
      }
    }
  }

  function handlePageInput(event) {
      const editableArea = event.target;
      const pageId = editableArea.dataset.pageId;

      if (pageId === 'cover' || pageId === 'back-cover' || pageId === 'placeholder' || isNaN(parseInt(pageId))) return;
      
      // Only author can save page content
      if (!isAuthor) return;

      clearTimeout(debounceTimeout);
      debounceTimeout = setTimeout(() => {
          const pageIndex = book.pages.findIndex(p => p.id == pageId);
          if (pageIndex > -1) {
              const content = editableArea.innerHTML;
              if (book.pages[pageIndex].content !== content) {
                book.pages[pageIndex].content = content;
                updatePage(pageId, { content: content });
              }
          }
      }, DEBOUNCE_DELAY);
  }
  
  function updateButtons() {
    if (!book) return;
    const numSheets = bookContainer.children.length;
    prevBtn.disabled = currentSpread === 0 || isFlipping;
    nextBtn.disabled = currentSpread >= numSheets || isFlipping;

    if (currentSpread === 0) {
        bookContainer.classList.add('closed');
    } else {
        bookContainer.classList.remove('closed');
    }
  }

  function flip(sheetElement, to) {
    isFlipping = true;
      sheetElement.classList.add('flipping');
    updateButtons();
    
    const numSheets = bookContainer.children.length;
    if (to === 'next') {
        sheetElement.classList.add('flipped');
        sheetElement.style.zIndex = currentSpread + numSheets;
    } else {
        sheetElement.classList.remove('flipped');
        sheetElement.style.zIndex = numSheets - currentSpread + 1;
    }

    setTimeout(() => {
      isFlipping = false;
      sheetElement.classList.remove('flipping');
      updateButtons();
      // Load highlights for newly visible pages
      loadHighlightsForCurrentSpread();
    }, FLIP_DURATION);
  }

  function goToNextSpread() {
    const numSheets = bookContainer.children.length;
    if (currentSpread < numSheets && !isFlipping) {
      const sheetToFlip = bookContainer.children[currentSpread];
      if (sheetToFlip) {
        flip(sheetToFlip, 'next');
        currentSpread++;
      }
    }
  }

  function goToPrevSpread() {
    if (currentSpread > 0 && !isFlipping) {
      currentSpread--;
      const sheetToFlip = bookContainer.children[currentSpread];
      if (sheetToFlip) {
        flip(sheetToFlip, 'prev');
      }
    }
  }
  
  // --- SEARCH FUNCTIONALITY ---
  let currentSearchQuery = ''; // Store current search query
  let currentSearchFoundInHighlight = false; // Store if search result was found in highlight
  
  function searchInBook(query) {
    if (!book || !book.pages || !query.trim()) {
      return [];
    }
    
    const searchTerm = query.toLowerCase().trim();
    const results = [];
    
    book.pages.forEach((page, index) => {
      const content = page.content || '';
      const plainText = content.replace(/<[^>]*>/g, ''); // Strip HTML
      const lowerContent = plainText.toLowerCase();
      
      // Also search in highlights for this page
      // Only search in current user's own highlights
      let highlightText = '';
      if (book.highlights && book.highlights.length > 0 && isAuthenticated && currentUserId > 0) {
        const pageHighlights = book.highlights.filter(h => {
          // Only include highlights that belong to current user
          return h.page_id === page.id && h.user_id === currentUserId;
        });
        highlightText = pageHighlights.map(h => h.highlighted_text || h.text || '').join(' ');
      }
      const lowerHighlightText = highlightText.toLowerCase();
      
      // Check if found in content or highlights
      const foundInContent = lowerContent.includes(searchTerm);
      const foundInHighlight = lowerHighlightText.includes(searchTerm);
      
      if (foundInContent || foundInHighlight) {
        // Prioritize highlight match, otherwise use content match
        let matchIndex, sourceText;
        if (foundInHighlight) {
          matchIndex = lowerHighlightText.indexOf(searchTerm);
          sourceText = highlightText;
        } else {
          matchIndex = lowerContent.indexOf(searchTerm);
          sourceText = plainText;
        }
        
        // Find context around the match
        const start = Math.max(0, matchIndex - 50);
        const end = Math.min(sourceText.length, matchIndex + searchTerm.length + 50);
        let snippet = sourceText.substring(start, end);
        
        // Add ellipsis
        if (start > 0) snippet = '...' + snippet;
        if (end < sourceText.length) snippet = snippet + '...';
        
        // Wrap snippet with %...% if from highlight
        if (foundInHighlight) {
          snippet = '%' + snippet + '%';
        }
        
        // Highlight the search term with special class for search results
        const regex = new RegExp(`(${searchTerm})`, 'gi');
        snippet = snippet.replace(regex, '<mark class="search-highlight">$1</mark>');
        
        results.push({
          pageIndex: index,
          pageNumber: page.page_number,
          snippet: snippet,
          foundInHighlight: foundInHighlight
        });
      }
    });
    
    return results;
  }
  
  function displaySearchResults(results, query) {
    bookSearchResults.innerHTML = '';
    
    if (results.length === 0) {
      bookSearchResults.innerHTML = '<div class="search-no-results">Kh√¥ng t√¨m th·∫•y k·∫øt qu·∫£</div>';
      bookSearchResults.style.display = 'block';
      return;
    }
    
    results.forEach(result => {
      const item = document.createElement('div');
      item.className = 'search-result-item';
      const highlightBadge = result.foundInHighlight ? '<span style="background: #fef08a; color: #854d0e; padding: 2px 6px; border-radius: 4px; font-size: 0.7rem; margin-left: 0.5rem; font-weight: 600;">‚ú® Highlight</span>' : '';
      item.innerHTML = `
        <div class="search-result-page">Trang ${result.pageNumber}${highlightBadge}</div>
        <div class="search-result-content">${result.snippet}</div>
      `;
      
      item.addEventListener('click', async () => {
        bookSearchResults.style.display = 'none';
        bookSearchInput.blur();
        currentSearchQuery = query; // Store query for highlighting
        currentSearchFoundInHighlight = result.foundInHighlight; // Store if found in highlight
        await goToPageByIndex(result.pageIndex);
      });
      
      bookSearchResults.appendChild(item);
    });
    
    bookSearchResults.style.display = 'block';
  }
  
  async function goToPageByIndex(pageIndex, fastFlip = true) {
    if (!book || !book.pages || isFlipping) return;
    
    const isMobile = window.innerWidth <= 767;
    
    if (isMobile) {
      // Mobile: Each page is a separate scroll item
      // Find the actual page element by data-page-id
      const allPages = bookContainer.querySelectorAll('.page');
      let targetPageElement = null;
      
      // pageIndex is the index in book.pages array
      // We need to find the page with matching page_number
      const targetPageData = book.pages[pageIndex];
      if (!targetPageData) return;
      
      // Find the page element with matching data-page-id
      for (const pageEl of allPages) {
        const editableArea = pageEl.querySelector('.editable-area');
        if (editableArea) {
          const pageId = editableArea.getAttribute('data-page-id');
          if (pageId == targetPageData.id) {
            targetPageElement = pageEl;
            break;
          }
        }
      }
      
      if (targetPageElement) {
        // Scroll to the page
        targetPageElement.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'start' });
        
        // After scrolling, highlight and scroll to search term
        if (currentSearchQuery) {
          setTimeout(() => {
            highlightAndScrollToSearchTermMobile(targetPageElement, currentSearchQuery);
          }, 500);
        }
      }
    } else {
      // Desktop: Use spread-based navigation
      // Calculate which spread contains this page
      // Page index starts at 0, each spread shows 2 pages
      // Spread 0: cover (page -1) and page 0
      // Spread 1: page 1 and page 2
      // Spread 2: page 3 and page 4
      // So: targetSpread = Math.ceil((pageIndex + 1) / 2)
      const targetSpread = Math.ceil((pageIndex + 1) / 2);
      
      // Use faster flip duration for search navigation
      const flipDelay = fastFlip ? 100 : FLIP_DURATION;
      
      // Flip to target spread with animation delay
      if (currentSpread < targetSpread) {
        // Flip forward
        while (currentSpread < targetSpread && currentSpread < bookContainer.children.length) {
          goToNextSpread();
          await new Promise(resolve => setTimeout(resolve, flipDelay));
        }
      } else if (currentSpread > targetSpread) {
        // Flip backward
        while (currentSpread > targetSpread && currentSpread > 0) {
          goToPrevSpread();
          await new Promise(resolve => setTimeout(resolve, flipDelay));
        }
      }
      
      // After flipping, highlight and scroll to search term
      if (currentSearchQuery) {
        setTimeout(() => {
          highlightAndScrollToSearchTerm(pageIndex, currentSearchQuery);
        }, flipDelay + 100);
      }
    }
  }
  
  function highlightAndScrollToSearchTermMobile(pageElement, query) {
    if (!query || !pageElement) return;
    
    const contentDiv = pageElement.querySelector('.page-content');
    if (!contentDiv) return;
    
    const searchTerm = query.toLowerCase().trim();
    
    // Find and highlight the search term in the page content
    const editableArea = contentDiv.querySelector('.editable-area');
    if (!editableArea) return;
    
    const text = editableArea.textContent.toLowerCase();
    if (!text.includes(searchTerm)) return;
    
    // Scroll the editable area to show the search term
    const walker = document.createTreeWalker(
      editableArea,
      NodeFilter.SHOW_TEXT,
      null,
      false
    );
    
    let node;
    while (node = walker.nextNode()) {
      const nodeText = node.textContent.toLowerCase();
      const index = nodeText.indexOf(searchTerm);
      
      if (index !== -1) {
        // Create a temporary span to scroll to
        const range = document.createRange();
        range.setStart(node, index);
        range.setEnd(node, index + searchTerm.length);
        
        const tempSpan = document.createElement('span');
        tempSpan.style.backgroundColor = 'rgba(59, 130, 246, 0.3)';
        tempSpan.style.padding = '0.1rem 0.2rem';
        tempSpan.style.borderRadius = '2px';
        
        try {
          range.surroundContents(tempSpan);
          tempSpan.scrollIntoView({ behavior: 'smooth', block: 'center' });
          
          // Remove highlight after 2 seconds
          setTimeout(() => {
            const parent = tempSpan.parentNode;
            if (parent) {
              parent.replaceChild(document.createTextNode(tempSpan.textContent), tempSpan);
              parent.normalize();
            }
          }, 2000);
        } catch (e) {
          console.warn('Could not highlight search term:', e);
        }
        
        break;
      }
    }
  }
  
  function highlightAndScrollToSearchTerm(pageIndex, query) {
    if (!query) return;
    
    // Find the page element
    const spread = bookContainer.children[currentSpread];
    if (!spread) return;
    
    const pages = spread.querySelectorAll('.page');
    let targetPage = null;
    
    // Determine if it's left or right page
    // pageIndex 0 is right page of spread 0
    // pageIndex 1 is left page of spread 1, etc.
    if (pageIndex === 0) {
      targetPage = pages[1]; // Right page of first spread
    } else {
      const isLeftPage = pageIndex % 2 === 1;
      targetPage = isLeftPage ? pages[0] : pages[1];
    }
    
    if (!targetPage) return;
    
    const contentDiv = targetPage.querySelector('.page-content');
    if (!contentDiv) return;
    
    const searchTerm = query.toLowerCase().trim();
    
    // If search was found in user highlight, just scroll to existing highlight
    if (currentSearchFoundInHighlight) {
      // Find existing user highlight (mark elements) containing the search term
      const highlightMarks = contentDiv.querySelectorAll('mark[data-highlight-id]');
      for (const mark of highlightMarks) {
        const text = mark.textContent.toLowerCase();
        if (text.includes(searchTerm)) {
          mark.scrollIntoView({ behavior: 'smooth', block: 'center' });
          // Add temporary pulse animation to existing highlight
          const originalAnimation = mark.style.animation;
          mark.style.animation = 'highlight-pulse 1s ease-in-out 2';
          setTimeout(() => {
            mark.style.animation = originalAnimation;
          }, 2000);
          break;
        }
      }
      currentSearchQuery = '';
      currentSearchFoundInHighlight = false;
      return;
    }
    
    // Otherwise, create search highlights for plain text search
    const walker = document.createTreeWalker(
      contentDiv,
      NodeFilter.SHOW_TEXT,
      null,
      false
    );
    
    let firstMatch = null;
    const nodesToHighlight = [];
    
    // Find all text nodes containing the search term (excluding user highlights)
    while (walker.nextNode()) {
      const node = walker.currentNode;
      
      // Skip if this text node is inside a user highlight
      const parentMark = node.parentElement?.closest('mark[data-highlight-id]');
      if (parentMark) continue;
      
      const text = node.textContent;
      const lowerText = text.toLowerCase();
      
      if (lowerText.includes(searchTerm)) {
        nodesToHighlight.push(node);
        if (!firstMatch) firstMatch = node;
      }
    }
    
    // Highlight all matches with search-highlight class
    nodesToHighlight.forEach(node => {
      const text = node.textContent;
      const lowerText = text.toLowerCase();
      const regex = new RegExp(`(${searchTerm})`, 'gi');
      
      if (regex.test(text)) {
        const span = document.createElement('span');
        span.innerHTML = text.replace(regex, '<mark class="search-highlight">$1</mark>');
        node.parentNode.replaceChild(span, node);
      }
    });
    
    // Scroll to first match
    if (firstMatch) {
      const mark = contentDiv.querySelector('mark.search-highlight');
      if (mark) {
        mark.scrollIntoView({ behavior: 'smooth', block: 'center' });
      }
    }
    
    // Clear search highlights after a delay
    setTimeout(() => {
      const marks = contentDiv.querySelectorAll('mark.search-highlight');
      marks.forEach(mark => {
        const parent = mark.parentNode;
        parent.replaceChild(document.createTextNode(mark.textContent), mark);
        parent.normalize();
      });
      currentSearchQuery = '';
      currentSearchFoundInHighlight = false;
    }, 3000);
  }
  
  // Search event listeners
  if (bookSearchInput) {
    let searchTimeout;
    
    bookSearchInput.addEventListener('input', (e) => {
      const query = e.target.value.trim();
      
      // Show/hide clear button
      if (query) {
        bookSearchClear.style.display = 'flex';
      } else {
        bookSearchClear.style.display = 'none';
        bookSearchResults.style.display = 'none';
        return;
      }
      
      // Debounce search
      clearTimeout(searchTimeout);
      searchTimeout = setTimeout(() => {
        const results = searchInBook(query);
        displaySearchResults(results, query);
      }, 300);
    });
    
    bookSearchInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        const query = bookSearchInput.value.trim();
        if (query) {
          const results = searchInBook(query);
          displaySearchResults(results, query);
        }
      } else if (e.key === 'Escape') {
        bookSearchResults.style.display = 'none';
        bookSearchInput.blur();
      }
    });
    
    if (bookSearchClear) {
      bookSearchClear.addEventListener('click', () => {
        bookSearchInput.value = '';
        bookSearchClear.style.display = 'none';
        bookSearchResults.style.display = 'none';
        bookSearchInput.focus();
      });
    }
    
    // Close search results when clicking outside
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.book-search-container')) {
        bookSearchResults.style.display = 'none';
      }
    });
  }
  
  // Mobile Search event listeners
  if (mobileSearchInput) {
    let mobileSearchTimeout;
    
    mobileSearchInput.addEventListener('input', (e) => {
      const query = e.target.value.trim();
      
      // Show/hide clear button
      if (query) {
        mobileSearchClear.style.display = 'flex';
      } else {
        mobileSearchClear.style.display = 'none';
        mobileSearchResults.style.display = 'none';
        return;
      }
      
      // Debounce search
      clearTimeout(mobileSearchTimeout);
      mobileSearchTimeout = setTimeout(() => {
        const results = searchInBook(query);
        displayMobileSearchResults(results, query);
      }, 300);
    });
    
    mobileSearchInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        const query = mobileSearchInput.value.trim();
        if (query) {
          const results = searchInBook(query);
          displayMobileSearchResults(results, query);
        }
      } else if (e.key === 'Escape') {
        mobileSearchResults.style.display = 'none';
        mobileSearchInput.blur();
      }
    });
    
    if (mobileSearchClear) {
      mobileSearchClear.addEventListener('click', () => {
        mobileSearchInput.value = '';
        mobileSearchClear.style.display = 'none';
        mobileSearchResults.style.display = 'none';
        mobileSearchInput.focus();
      });
    }
    
    // Close search results when clicking outside
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.search-container-mobile')) {
        mobileSearchResults.style.display = 'none';
      }
    });
  }
  
  // Display mobile search results
  function displayMobileSearchResults(results, query) {
    mobileSearchResults.innerHTML = '';
    
    if (results.length === 0) {
      mobileSearchResults.innerHTML = '<div class="search-no-results">Kh√¥ng t√¨m th·∫•y k·∫øt qu·∫£</div>';
      mobileSearchResults.style.display = 'block';
      return;
    }
    
    results.forEach(result => {
      const item = document.createElement('div');
      item.className = 'search-result-item';
      const highlightBadge = result.foundInHighlight ? '<span style="background: #fef08a; color: #854d0e; padding: 2px 6px; border-radius: 4px; font-size: 0.7rem; margin-left: 0.5rem; font-weight: 600;">‚ú® Highlight</span>' : '';
      item.innerHTML = `
        <div class="search-result-page">Trang ${result.pageNumber}${highlightBadge}</div>
        <div class="search-result-content">${result.snippet}</div>
      `;
      
      item.addEventListener('click', async () => {
        mobileSearchResults.style.display = 'none';
        mobileSearchInput.blur();
        
        currentSearchQuery = query; // Store query for highlighting
        currentSearchFoundInHighlight = result.foundInHighlight; // Store if found in highlight
        
        // Find the target page by matching page number
        // result.pageNumber is the actual page number from database
        const pages = Array.from(bookContainer.querySelectorAll('.page'));
        
        console.log('Mobile search click - pageIndex:', result.pageIndex, 'pageNumber:', result.pageNumber, 'total pages:', pages.length);
        
        // Find page by page number displayed
        let targetPage = null;
        
        // First try: Find by displayed page number
        for (const page of pages) {
          const pageNumberElem = page.querySelector('.page-number-left, .page-number-right');
          if (pageNumberElem) {
            const displayedPageNum = parseInt(pageNumberElem.textContent);
            if (displayedPageNum === result.pageNumber) {
              targetPage = page;
              console.log('Found target page by number:', result.pageNumber);
              break;
            }
          }
        }
        
        // Fallback: Use index-based approach if page number search failed
        // Mobile structure: pages[0] = cover, pages[1] = page 1, pages[2] = page 2, etc.
        if (!targetPage) {
          console.log('Page number search failed, trying index-based approach');
          console.log('All pages with numbers:');
          pages.forEach((p, idx) => {
            const numElem = p.querySelector('.page-number-left, .page-number-right');
            console.log(`  pages[${idx}]: ${numElem ? numElem.textContent : 'no number'}`);
          });
          
          // result.pageIndex is 0-based index in book.pages (no cover)
          // DOM index = result.pageIndex + 1 (because cover is at index 0)
          const domIndex = result.pageIndex + 1;
          console.log('Calculated domIndex:', domIndex);
          if (pages[domIndex]) {
            targetPage = pages[domIndex];
            console.log('Found target page by index:', domIndex);
          } else {
            console.error('domIndex out of bounds:', domIndex, 'total pages:', pages.length);
          }
        }
        
        if (targetPage) {
          console.log('Scrolling to target page');
          targetPage.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'start' });
          
          // Highlight search term on mobile after scroll
          setTimeout(() => {
            highlightSearchTermOnMobilePage(targetPage, query);
          }, 500);
        } else {
          console.error('Page not found - pageNumber:', result.pageNumber, 'pageIndex:', result.pageIndex, 'Available pages:', pages.length);
        }
      });
      
      mobileSearchResults.appendChild(item);
    });
    
    mobileSearchResults.style.display = 'block';
  }
  
  // Highlight search term on mobile page
  function highlightSearchTermOnMobilePage(pageElement, query) {
    if (!query || !pageElement) return;
    
    const contentDiv = pageElement.querySelector('.page-content');
    if (!contentDiv) return;
    
    const searchTerm = query.toLowerCase().trim();
    
    // If search was found in user highlight, just scroll to existing highlight
    if (currentSearchFoundInHighlight) {
      // Find existing user highlight (mark elements) containing the search term
      const highlightMarks = contentDiv.querySelectorAll('mark[data-highlight-id]');
      for (const mark of highlightMarks) {
        const text = mark.textContent.toLowerCase();
        if (text.includes(searchTerm)) {
          mark.scrollIntoView({ behavior: 'smooth', block: 'center' });
          // Add temporary pulse animation to existing highlight
          const originalAnimation = mark.style.animation;
          mark.style.animation = 'highlight-pulse 1s ease-in-out 2';
          setTimeout(() => {
            mark.style.animation = originalAnimation;
          }, 2000);
          break;
        }
      }
      currentSearchFoundInHighlight = false;
      return;
    }
    
    // Otherwise, create search highlights for plain text search
    const walker = document.createTreeWalker(
      contentDiv,
      NodeFilter.SHOW_TEXT,
      null,
      false
    );
    
    let firstMatch = null;
    const nodesToHighlight = [];
    
    // Find all text nodes containing the search term (excluding user highlights)
    while (walker.nextNode()) {
      const node = walker.currentNode;
      
      // Skip if this text node is inside a user highlight
      const parentMark = node.parentElement?.closest('mark[data-highlight-id]');
      if (parentMark) continue;
      
      const text = node.textContent;
      const lowerText = text.toLowerCase();
      
      if (lowerText.includes(searchTerm)) {
        nodesToHighlight.push(node);
        if (!firstMatch) firstMatch = node;
      }
    }
    
    // Highlight all matches with search-highlight class
    nodesToHighlight.forEach(node => {
      const text = node.textContent;
      const regex = new RegExp(`(${searchTerm})`, 'gi');
      
      if (regex.test(text)) {
        const span = document.createElement('span');
        span.innerHTML = text.replace(regex, '<mark class="search-highlight">$1</mark>');
        node.parentNode.replaceChild(span, node);
      }
    });
    
    // Scroll to first match within page
    if (firstMatch) {
      const mark = contentDiv.querySelector('mark.search-highlight');
      if (mark) {
        mark.scrollIntoView({ behavior: 'smooth', block: 'center' });
      }
    }
    
    // Clear search highlights after 3 seconds
    setTimeout(() => {
      const marks = contentDiv.querySelectorAll('mark.search-highlight');
      marks.forEach(mark => {
        const parent = mark.parentNode;
        parent.replaceChild(document.createTextNode(mark.textContent), mark);
        parent.normalize(); // Merge adjacent text nodes
      });
      currentSearchFoundInHighlight = false;
    }, 3000);
  }
  
  // Mobile Menu Toggle
  const mobileMenuBtn = document.getElementById('mobile-menu-btn');
  const mobileMenuDropdown = document.getElementById('mobile-menu-dropdown');
  const mobileSettingsBtn = document.getElementById('mobile-settings-btn');
  const mobileAddPageBtn = document.getElementById('mobile-add-page-btn');
  const mobileBoldBtn = document.getElementById('mobile-bold-btn');
  const mobileItalicBtn = document.getElementById('mobile-italic-btn');
  const mobileUnderlineBtn = document.getElementById('mobile-underline-btn');
  const mobileImageBtn = document.getElementById('mobile-image-btn');
  const mobileFontsizeBtn = document.getElementById('mobile-fontsize-btn');
  const mobileFontcolorBtn = document.getElementById('mobile-fontcolor-btn');
  const mobileTableBtn = document.getElementById('mobile-table-btn');
  
  if (mobileMenuBtn) {
    // Save selection variable
    let savedMobileSelection = null;
    
    mobileMenuBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      
      // Save current selection when opening menu
      if (activeEditableArea) {
        savedMobileSelection = saveSelection(activeEditableArea);
      }
      
      const isVisible = mobileMenuDropdown.style.display === 'block';
      mobileMenuDropdown.style.display = isVisible ? 'none' : 'block';
    });
    
    // Close menu when clicking outside
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.mobile-top-bar')) {
        mobileMenuDropdown.style.display = 'none';
      }
    });
    
    // Mobile settings button
    if (mobileSettingsBtn) {
      mobileSettingsBtn.addEventListener('click', () => {
        mobileMenuDropdown.style.display = 'none';
        // Trigger desktop settings button
        const desktopSettingsBtn = document.getElementById('book-settings-btn');
        if (desktopSettingsBtn) {
          desktopSettingsBtn.click();
        }
      });
    }
    
    // Mobile add page button
    if (mobileAddPageBtn) {
      mobileAddPageBtn.addEventListener('click', () => {
        mobileMenuDropdown.style.display = 'none';
        handleAddPage();
      });
    }
    
    // Mobile Bold
    if (mobileBoldBtn) {
      mobileBoldBtn.addEventListener('click', () => {
        mobileMenuDropdown.style.display = 'none';
        if (savedMobileSelection && activeEditableArea) {
          restoreSelection(activeEditableArea, savedMobileSelection);
        }
        formatDoc('bold');
        savedMobileSelection = null;
      });
    }
    
    // Mobile Italic
    if (mobileItalicBtn) {
      mobileItalicBtn.addEventListener('click', () => {
        mobileMenuDropdown.style.display = 'none';
        if (savedMobileSelection && activeEditableArea) {
          restoreSelection(activeEditableArea, savedMobileSelection);
        }
        formatDoc('italic');
        savedMobileSelection = null;
      });
    }
    
    // Mobile Underline
    if (mobileUnderlineBtn) {
      mobileUnderlineBtn.addEventListener('click', () => {
        mobileMenuDropdown.style.display = 'none';
        if (savedMobileSelection && activeEditableArea) {
          restoreSelection(activeEditableArea, savedMobileSelection);
        }
        formatDoc('underline');
        savedMobileSelection = null;
      });
    }
    
    // Mobile Image
    if (mobileImageBtn) {
      mobileImageBtn.addEventListener('click', () => {
        mobileMenuDropdown.style.display = 'none';
        imageUpload.click();
      });
    }
    
    // Mobile Font Size
    if (mobileFontsizeBtn) {
      mobileFontsizeBtn.addEventListener('click', () => {
        mobileMenuDropdown.style.display = 'none';
        fontsizeBtn.click(); // Trigger desktop button
      });
    }
    
    // Mobile Font Color
    if (mobileFontcolorBtn) {
      mobileFontcolorBtn.addEventListener('click', () => {
        mobileMenuDropdown.style.display = 'none';
        fontcolorBtn.click(); // Trigger desktop button
      });
    }
    
    // Mobile Table
    if (mobileTableBtn) {
      mobileTableBtn.addEventListener('click', () => {
        mobileMenuDropdown.style.display = 'none';
        tableBtn.click(); // Trigger desktop button
      });
    }
  }
  
  
  // Keyboard navigation
  document.addEventListener('keydown', (e) => {
    // Only handle arrow keys if not typing in editable area
    if (e.target.getAttribute('contenteditable') === 'true') {
      return; // Don't interfere with typing
    }
    
    if (e.key === 'ArrowLeft') {
      e.preventDefault();
      goToPrevSpread();
    } else if (e.key === 'ArrowRight') {
      e.preventDefault();
      goToNextSpread();
    }
  });

  async function handleAddPage() {
    // Check authentication first
    if (!isAuthenticated) {
        alert("Vui l√≤ng ƒëƒÉng nh·∫≠p ƒë·ªÉ th√™m trang m·ªõi!");
        return;
    }
    
    addPageBtn.disabled = true;
    
    try {
        // SAVE DATA OF CURRENTLY EDITED PAGE BEFORE ADDING NEW PAGES
        // This prevents data loss when renderBook() re-renders
        const currentEditableArea = document.querySelector('.editable-area:focus') || document.querySelector('.editable-area[contenteditable="true"]');
        if (currentEditableArea) {
            // Force save current page content
            const pageId = currentEditableArea.dataset.pageId;
            if (pageId && pageId !== 'cover' && pageId !== 'back-cover' && pageId !== 'placeholder' && !isNaN(parseInt(pageId))) {
                const pageIndex = book.pages.findIndex(p => p.id == pageId);
                if (pageIndex > -1) {
                    const content = currentEditableArea.innerHTML;
                    if (book.pages[pageIndex].content !== content) {
                        book.pages[pageIndex].content = content;
                        await updatePage(pageId, { content: content });
                        console.log("Saved current page content before adding new pages");
                    }
                }
            }
        }
        
        // Since renderBook() now creates real pages instead of placeholders,
        // we need to get the actual last page number from the database
        const lastPageNum = book.pages.length > 0 ? Math.max(...book.pages.map(p => p.page_number)) : 0;
        
        // We always add two pages to maintain the even layout
        const newPage1Data = { page_number: lastPageNum + 1, title: `Page ${lastPageNum + 1}`, content: '' };
        const newPage2Data = { page_number: lastPageNum + 2, title: `Page ${lastPageNum + 2}`, content: '' };
        
        const createdPage1 = await createPage(newPage1Data);
        if (createdPage1) {
            book.pages.push(createdPage1);
            console.log("Page 1 added:", createdPage1);
        }

        const createdPage2 = await createPage(newPage2Data);
        if (createdPage2) {
            book.pages.push(createdPage2);
            console.log("Page 2 added:", createdPage2);
        }
        
        // Sort and re-render immediately for live update
        book.pages.sort((a, b) => a.page_number - b.page_number);
        await renderBook(); // Use await since renderBook is now async
        
        // Auto-flip to the new pages
        setTimeout(() => {
            const numSheets = bookContainer.children.length;
            if (currentSpread < numSheets - 1) {
                goToNextSpread();
            }
        }, 300);
    } catch (error) {
        console.error("Error adding pages:", error);
        alert("Kh√¥ng th·ªÉ th√™m trang. Vui l√≤ng ƒëƒÉng nh·∫≠p v√† th·ª≠ l·∫°i.");
    } finally {
        addPageBtn.disabled = false;
    }
  }

  function formatDoc(cmd, value = null) {
    if (activeEditableArea) {
        activeEditableArea.focus();
        document.execCommand(cmd, false, value);
        const event = new Event('input', { bubbles: true, cancelable: true });
        activeEditableArea.dispatchEvent(event);
    }
  }
  
  function triggerSave(element) {
    if(element) {
        const event = new Event('input', { bubbles: true, cancelable: true });
        element.dispatchEvent(event);
    }
  }

  // --- MODAL LOGIC ---
  function showInputModal(title, fields, callback) {
    inputModalTitle.textContent = title;
    inputModalContent.innerHTML = '';
    fields.forEach(field => {
        const label = `<label for="modal-input-${field.id}">${field.label}</label>`;
        let input;
        if (field.type === 'color') {
              input = `<input type="color" id="modal-input-${field.id}" value="${field.value || ''}">`;
        } else {
              input = `<input type="${field.type || 'text'}" id="modal-input-${field.id}" placeholder="${field.placeholder || ''}" value="${field.value || ''}">`;
        }
        inputModalContent.innerHTML += label + input;
    });
    inputModal.style.display = 'block';
    inputModalOverlay.style.display = 'block';
    inputModalCallback = callback;
  }

  function hideInputModal() {
      inputModal.style.display = 'none';
      inputModalOverlay.style.display = 'none';
      inputModalCallback = null;
  }
  
  // Selection save/restore functions
  function saveSelection(containerEl) {
    const selection = window.getSelection();
    if (selection.rangeCount > 0) {
      const range = selection.getRangeAt(0);
      return {
        startContainer: range.startContainer,
        startOffset: range.startOffset,
        endContainer: range.endContainer,
        endOffset: range.endOffset,
        commonAncestorContainer: range.commonAncestorContainer
      };
    }
    return null;
  }
  
  function restoreSelection(containerEl, savedSel) {
    if (savedSel) {
      const selection = window.getSelection();
      selection.removeAllRanges();
      const range = document.createRange();
      range.setStart(savedSel.startContainer, savedSel.startOffset);
      range.setEnd(savedSel.endContainer, savedSel.endOffset);
      selection.addRange(range);
    }
  }
  
  inputModalSaveBtn.addEventListener('click', () => {
      if (inputModalCallback) {
          const inputs = inputModalContent.querySelectorAll('input');
          const values = {};
          inputs.forEach(input => {
              values[input.id.replace('modal-input-', '')] = input.value;
          });
          inputModalCallback(values);
      }
      hideInputModal();
  });
  inputModalCancelBtn.addEventListener('click', hideInputModal);

  // --- TOOLBAR EVENT LISTENERS ---
  boldBtn.addEventListener('click', () => formatDoc('bold'));
  italicBtn.addEventListener('click', () => formatDoc('italic'));
  underlineBtn.addEventListener('click', () => formatDoc('underline'));
  imageBtn.addEventListener('click', () => imageUpload.click());

  fontsizeBtn.addEventListener('click', () => {
    if (!activeEditableArea) {
      activeEditableArea = document.querySelector('.editable-area:focus') || document.querySelector('.editable-area[contenteditable="true"]');
    }
    
    // Save current selection before showing modal
    const savedSelection = saveSelection(activeEditableArea);
    
    if (activeEditableArea) {
      activeEditableArea.focus();
    }
    
    showInputModal('Font Size', [{id: 'size', label: 'Enter font size (e.g., 16px):'}], (values) => {
      if (values.size && activeEditableArea) {
        // Restore selection
        restoreSelection(activeEditableArea, savedSelection);
        
        const selection = window.getSelection();
        if (selection.rangeCount > 0 && selection.toString().length > 0) {
          const range = selection.getRangeAt(0);
          const span = document.createElement('span');
          span.style.fontSize = values.size;
          try {
            span.appendChild(range.extractContents());
            range.insertNode(span);
            triggerSave(activeEditableArea);
          } catch(e) { 
            console.error('Font size error:', e); 
          }
        } else {
          // Apply to entire editable area if no selection
          activeEditableArea.style.fontSize = values.size;
          triggerSave(activeEditableArea);
        }
      }
    });
  });
  
  fontcolorBtn.addEventListener('click', () => {
    if (!activeEditableArea) {
      activeEditableArea = document.querySelector('.editable-area:focus') || document.querySelector('.editable-area[contenteditable="true"]');
    }
    
    // Save current selection before showing modal
    const savedSelection = saveSelection(activeEditableArea);
    
    if (activeEditableArea) {
      activeEditableArea.focus();
    }
    
    showInputModal('M√†u ch·ªØ', [{id: 'color', label: 'ƒê·ªïi m√†u ch·ªØ:', type: 'color', value: '#ffffff'}], (values) => {
      if (values.color && activeEditableArea) {
        // Restore selection
        restoreSelection(activeEditableArea, savedSelection);
        
        const selection = window.getSelection();
        if (selection.rangeCount > 0 && selection.toString().length > 0) {
          const range = selection.getRangeAt(0);
          const span = document.createElement('span');
          span.style.color = values.color;
          try {
            span.appendChild(range.extractContents());
            range.insertNode(span);
            triggerSave(activeEditableArea);
          } catch(e) { 
            console.error('Font color error:', e); 
          }
        } else {
          // Apply to entire editable area if no selection
          activeEditableArea.style.color = values.color;
          triggerSave(activeEditableArea);
        }
      }
    });
  });
  
  tableBtn.addEventListener('click', () => {
    if (!activeEditableArea) {
      activeEditableArea = document.querySelector('.editable-area:focus') || document.querySelector('.editable-area[contenteditable="true"]');
    }
    
    // Save current selection before showing modal
    const savedSelection = saveSelection(activeEditableArea);
    
    if (activeEditableArea) {
      activeEditableArea.focus();
    }
    
    showInputModal('T·∫°o b·∫£ng', [
        {id: 'rows', label: 'S·ªë h√†ng:', type: 'number', value: '3'},
        {id: 'cols', label: 'S·ªë c·ªôt:', type: 'number', value: '3'}
    ], (values) => {
      const rows = parseInt(values.rows, 10);
      const cols = parseInt(values.cols, 10);
      if (rows > 0 && cols > 0 && activeEditableArea) {
          // Restore selection
          restoreSelection(activeEditableArea, savedSelection);
          
          let table = '<table border="1"><tbody>';
          for (let i = 0; i < rows; i++) {
              table += '<tr>';
              for (let j = 0; j < cols; j++) {
                  table += '<td>&nbsp;</td>';
              }
              table += '</tr>';
          }
          table += '</tbody></table>';
          
          const selection = window.getSelection();
          if (selection.rangeCount > 0) {
            const range = selection.getRangeAt(0);
            const div = document.createElement('div');
            div.innerHTML = table + '<p></p>';
            try {
              range.insertNode(div);
              triggerSave(activeEditableArea);
            } catch(e) { 
              console.error('Table insert error:', e); 
            }
          } else {
            // Fallback: insert at end of editable area
            activeEditableArea.innerHTML += '<p></p>' + table + '<p></p>';
            triggerSave(activeEditableArea);
          }
      }
    });
  });

  imageUpload.addEventListener('change', () => {
    const file = imageUpload.files[0];
    if (file && activeEditableArea) {
        const reader = new FileReader();
        reader.onload = (e) => {
            const img = `<img src="${e.target.result}" style="max-width: 100%;" />`;
            formatDoc('insertHTML', img);
        };
        reader.readAsDataURL(file);
    }
    imageUpload.value = '';
  });


  // --- HIGHLIGHT LOGIC ---
  function showHighlightPopover(range) {
    const rect = range.getBoundingClientRect();
    highlightPopover.style.display = 'flex';
    highlightPopover.style.left = `${rect.left + window.scrollX + rect.width / 2 - highlightPopover.offsetWidth / 2}px`;
    
    // On mobile, show below selection to avoid native popover
    const isMobile = window.innerWidth <= 767;
    if (isMobile) {
      highlightPopover.style.top = `${rect.bottom + window.scrollY + 8}px`;
    } else {
      highlightPopover.style.top = `${rect.top + window.scrollY - highlightPopover.offsetHeight - 8}px`;
    }
  }
  
  function hideHighlightPopover() {
    highlightPopover.style.display = 'none';
  }

  function showHighlightModal() {
    // Check if selection is within an existing highlight
    let existingMark = null;
    let existingNote = '';
    let existingColor = 'var(--highlight-yellow)';
    
    if (currentSelection) {
        const ancestor = currentSelection.commonAncestorContainer;
        existingMark = ancestor.nodeType === Node.ELEMENT_NODE ? ancestor.closest('mark') : ancestor.parentElement?.closest('mark');
        
        if (existingMark) {
            // Load existing highlight data
            const noteElement = existingMark.querySelector('.highlight-note');
            if (noteElement) {
                existingNote = noteElement.textContent;
            }
            existingColor = window.getComputedStyle(existingMark).backgroundColor;
        }
    }
    
    // Show/hide remove button based on whether editing existing highlight
    if (existingMark) {
        highlightModalRemoveBtn.style.display = 'inline-block';
    } else {
        highlightModalRemoveBtn.style.display = 'none';
    }
    
    // Set note input
    noteInput.value = existingNote;
    
    // Set color picker
    const selectedColor = colorPicker.querySelector('.selected');
    if(selectedColor) selectedColor.classList.remove('selected');
    
    // Try to match existing color or default to first
    let colorMatched = false;
    if (existingMark) {
        const colorBoxes = colorPicker.querySelectorAll('.color-box');
        for (const box of colorBoxes) {
            const boxColor = window.getComputedStyle(box).backgroundColor;
            if (boxColor === existingColor) {
                box.classList.add('selected');
                colorMatched = true;
                break;
            }
        }
    }
    
    if (!colorMatched) {
        colorPicker.children[0].classList.add('selected');
    }

    highlightModalOverlay.style.display = 'block';
    highlightModal.style.display = 'block';
  }

  function hideHighlightModal() {
    highlightModalOverlay.style.display = 'none';
    highlightModal.style.display = 'none';
    currentSelection = null;
  }
  
  document.addEventListener('mouseup', (e) => {
      setTimeout(() => {
        // Don't show highlight popover if not authenticated
        if (!isAuthenticated) {
            return;
        }
        
        const selection = window.getSelection();
        if (selection.isCollapsed || isFlipping || highlightModal.style.display === 'block' || inputModal.style.display === 'block') {
            hideHighlightPopover();
            return;
        }
        
        const range = selection.getRangeAt(0);
        let editable = range.commonAncestorContainer.nodeType === Node.ELEMENT_NODE
            ? range.commonAncestorContainer.closest('.editable-area')
            : range.commonAncestorContainer.parentElement.closest('.editable-area');

        if (editable) {
            // Check if we're on a cover page - don't allow highlight on cover
            const coverPage = editable.closest('.is-cover, .is-back-cover');
            if (coverPage) {
                hideHighlightPopover();
                return;
            }
            
            currentSelection = range.cloneRange();
            showHighlightPopover(range);
        } else {
            hideHighlightPopover();
        }
      }, 10);
  });
  
  document.addEventListener('touchend', (e) => {
      setTimeout(() => {
        // Don't show highlight popover if not authenticated
        if (!isAuthenticated) {
            return;
        }
        
        const selection = window.getSelection();
        if (selection.isCollapsed || isFlipping || highlightModal.style.display === 'block' || inputModal.style.display === 'block') {
            hideHighlightPopover();
            return;
        }
        
        const range = selection.getRangeAt(0);
        let editable = range.commonAncestorContainer.nodeType === Node.ELEMENT_NODE
            ? range.commonAncestorContainer.closest('.editable-area')
            : range.commonAncestorContainer.parentElement.closest('.editable-area');

        if (editable) {
            // Check if we're on a cover page - don't allow highlight on cover
            const coverPage = editable.closest('.is-cover, .is-back-cover');
            if (coverPage) {
                hideHighlightPopover();
                return;
            }
            
            currentSelection = range.cloneRange();
            showHighlightPopover(range);
        } else {
            hideHighlightPopover();
        }
      }, 10);
  });
  
  document.addEventListener('mousedown', (e) => {
      if (!highlightPopover.contains(e.target)) {
          hideHighlightPopover();
      }
  });
  
  // Mobile: hide popover on touch outside
  document.addEventListener('touchstart', (e) => {
      if (!highlightPopover.contains(e.target)) {
          hideHighlightPopover();
      }
  });
  
  document.addEventListener('click', (e) => {
    if(e.target.tagName === 'IMG' && e.target.closest('.editable-area')) {
        selectedImage = e.target;
        showInputModal('Image Size', [{id: 'width', label: 'Enter new image width (e.g., 300px or 50%):', value: selectedImage.style.width}], (values) => {
            if(values.width) {
                selectedImage.style.width = values.width;
                selectedImage.style.height = 'auto';
                triggerSave(selectedImage.closest('.editable-area'));
            }
            selectedImage = null;
        });
    }
  });

  popoverHighlightBtn.addEventListener('click', () => {
      if (currentSelection) {
          hideHighlightPopover();
          showHighlightModal();
      }
  });

  popoverRemoveHighlightBtn.addEventListener('click', async () => {
    if(currentSelection) {
        const ancestor = currentSelection.commonAncestorContainer;
        const mark = ancestor.nodeType === Node.ELEMENT_NODE ? ancestor.closest('mark') : ancestor.parentElement.closest('mark');
        if(mark) {
            const highlightId = mark.getAttribute('data-highlight-id');
            const editableArea = mark.closest('.editable-area');
            const pageId = editableArea ? editableArea.dataset.pageId : null;
            
            // Remove from DOM
            const parent = mark.parentNode;
            while (mark.firstChild) {
                parent.insertBefore(mark.firstChild, mark);
            }
            parent.removeChild(mark);
            parent.normalize(); // Merges adjacent text nodes
            
            // Delete from database if it has an ID
            if (highlightId && highlightId !== 'pending' && pageId) {
                await deleteHighlight(pageId, highlightId);
            }
            
            triggerSave(parent.closest('.editable-area'));
        }
        hideHighlightPopover();
        window.getSelection().removeAllRanges();
    }
  });

  colorPicker.addEventListener('click', (e) => {
      if(e.target.classList.contains('color-box')) {
          const selectedColor = colorPicker.querySelector('.selected');
          if(selectedColor) selectedColor.classList.remove('selected');
          e.target.classList.add('selected');
      }
  });

  highlightModalCancelBtn.addEventListener('click', hideHighlightModal);

  highlightModalRemoveBtn.addEventListener('click', async () => {
    if (!currentSelection) return;
    
    // Find existing mark
    const ancestor = currentSelection.commonAncestorContainer;
    const existingMark = ancestor.nodeType === Node.ELEMENT_NODE ? ancestor.closest('mark') : ancestor.parentElement?.closest('mark');
    
    if (existingMark) {
        const highlightId = existingMark.getAttribute('data-highlight-id');
        const editableArea = existingMark.closest('.editable-area');
        const pageId = editableArea ? editableArea.dataset.pageId : null;
        
        // Remove from DOM
        const parent = existingMark.parentNode;
        while (existingMark.firstChild) {
            parent.insertBefore(existingMark.firstChild, existingMark);
        }
        parent.removeChild(existingMark);
        parent.normalize(); // Merges adjacent text nodes
        
        // Delete from database if it has an ID
        if (highlightId && highlightId !== 'pending' && pageId) {
            await deleteHighlight(pageId, highlightId);
        }
        
        triggerSave(parent.closest('.editable-area'));
    }
    
    hideHighlightModal();
    window.getSelection().removeAllRanges();
  });

  highlightModalSaveBtn.addEventListener('click', async () => {
    if (!currentSelection) return;

    const noteText = noteInput.value;
    const selectedColorEl = colorPicker.querySelector('.selected');
    const color = selectedColorEl.dataset.color;
    const highlightedText = currentSelection.toString();

    // Check if we're editing an existing highlight
    const ancestor = currentSelection.commonAncestorContainer;
    const existingMark = ancestor.nodeType === Node.ELEMENT_NODE ? ancestor.closest('mark') : ancestor.parentElement?.closest('mark');

    // Get the editable area and page ID
    const editableArea = currentSelection.commonAncestorContainer.nodeType === Node.ELEMENT_NODE
        ? currentSelection.commonAncestorContainer.closest('.editable-area')
        : currentSelection.commonAncestorContainer.parentElement.closest('.editable-area');
    
    if (!editableArea) {
        console.error("Could not find editable area");
        hideHighlightModal();
        return;
    }

    const pageId = editableArea.dataset.pageId;
    if (pageId === 'cover' || pageId === 'back-cover' || pageId === 'placeholder' || isNaN(parseInt(pageId))) {
        console.warn("Cannot highlight on special pages");
        hideHighlightModal();
        return;
    }

    if (existingMark) {
        // Update existing highlight
        existingMark.style.backgroundColor = color;
        
        // Update or add note
        let noteSpan = existingMark.querySelector('.highlight-note');
        if (noteText) {
            if (!noteSpan) {
                noteSpan = document.createElement('span');
                noteSpan.className = 'highlight-note';
                // Insert at the beginning (will be hidden by CSS)
                existingMark.insertBefore(noteSpan, existingMark.firstChild);
            }
            noteSpan.textContent = noteText;
        } else if (noteSpan) {
            noteSpan.remove();
        }
        
        // Update in database if it has an ID
        const highlightId = existingMark.getAttribute('data-highlight-id');
        if (highlightId && highlightId !== 'pending') {
            // Note: You may need to add an update endpoint, for now we'll just trigger save
            triggerSave(editableArea);
        }
    } else {
        // Create new highlight
        // Calculate offsets relative to the editable area's text content
        const range = currentSelection.cloneRange();
        const preRange = document.createRange();
        preRange.selectNodeContents(editableArea);
        preRange.setEnd(range.startContainer, range.startOffset);
        const startOffset = preRange.toString().length;
        const endOffset = startOffset + highlightedText.length;

        // Apply visual highlight
        const mark = document.createElement('mark');
        mark.style.backgroundColor = color;
        mark.setAttribute('data-highlight-id', 'pending'); // Will be updated after save
        
        if (noteText) {
            const noteSpan = document.createElement('span');
            noteSpan.className = 'highlight-note';
            noteSpan.textContent = noteText;
            mark.appendChild(noteSpan);
        }

        try {
          mark.appendChild(currentSelection.extractContents());
          currentSelection.insertNode(mark);
        } catch(e) {
            console.error("Could not apply highlight:", e);
            hideHighlightModal();
            return;
        }

        // Save to database
        const highlightData = {
            color: color,
            highlighted_text: highlightedText,
            note: noteText,
            start_offset: startOffset,
            end_offset: endOffset
        };

        const savedHighlight = await saveHighlight(pageId, highlightData);
        if (savedHighlight) {
            mark.setAttribute('data-highlight-id', savedHighlight.id);
            console.log("Highlight saved with ID:", savedHighlight.id);
        }

        triggerSave(mark.closest('.editable-area'));
    }

    hideHighlightModal();
    window.getSelection().removeAllRanges();
  });

  // --- BOOK SETTINGS MODAL ---
  {{if .IsAuthor}}
  const bookSettingsBtn = document.getElementById('book-settings-btn');
  const bookSettingsModal = document.getElementById('book-settings-modal');
  const bookSettingsForm = document.getElementById('book-settings-form');
  const closeBookSettingsBtns = document.querySelectorAll('[data-action="close-book-settings"]');

  if (bookSettingsBtn && bookSettingsModal) {
      bookSettingsBtn.addEventListener('click', () => {
          bookSettingsModal.style.display = 'flex';
      });

      closeBookSettingsBtns.forEach(btn => {
          btn.addEventListener('click', () => {
              bookSettingsModal.style.display = 'none';
          });
      });

      bookSettingsModal.addEventListener('click', (e) => {
          if (e.target === bookSettingsModal) {
              bookSettingsModal.style.display = 'none';
          }
      });

      // Handle form submission
      if (bookSettingsForm) {
          bookSettingsForm.addEventListener('submit', async (e) => {
              e.preventDefault();
              
              const formData = new FormData(bookSettingsForm);
              const data = {
                  title: formData.get('title'),
                  description: formData.get('description'),
                  cover_url: formData.get('cover_url'),
                  cover_color: formData.get('cover_color'),
                  published: formData.get('published') === 'on',
                  book_tag: formData.get('book_tag'),
                  book_category: formData.get('book_category')
              };

              try {
                  const response = await fetch(`/books/${BOOK_ID}/edit`, {
                      method: 'POST',
                      headers: { 'Content-Type': 'application/json' },
                      body: JSON.stringify(data)
                  });

                  const result = await response.json();
                  if (result.success) {
                      // Update the book data
                      book.title = data.title;
                      book.description = data.description;
                      book.cover_url = data.cover_url;
                      book.cover_color = data.cover_color;
                      book.published = data.published;
                      book.book_tag = data.book_tag;
                      book.book_category = data.book_category;
                      
                      // Live update cover without full re-render
                      updateCoverDisplay();
                      
                      // Broadcast update to other pages via localStorage
                      const updateEvent = {
                          type: 'book_updated',
                          bookId: BOOK_ID,
                          data: {
                              title: data.title,
                              description: data.description,
                              cover_url: data.cover_url,
                              cover_color: data.cover_color,
                              book_tag: data.book_tag,
                              book_category: data.book_category,
                              author_name: book.author_name
                          },
                          timestamp: Date.now()
                      };
                      localStorage.setItem('book_update_event', JSON.stringify(updateEvent));
                      
                      // Also try postMessage to parent if in iframe
                      if (window.parent !== window) {
                          window.parent.postMessage(updateEvent, '*');
                      }
                      
                      bookSettingsModal.style.display = 'none';
                      alert('C·∫≠p nh·∫≠t s√°ch th√†nh c√¥ng!');
                  } else {
                      alert(result.error || 'L·ªói c·∫≠p nh·∫≠t s√°ch');
                  }
              } catch (error) {
                  console.error('Error updating book:', error);
                  alert('L·ªói k·∫øt n·ªëi khi c·∫≠p nh·∫≠t s√°ch');
              }
          });

          // Handle cancel
          document.querySelector('[data-action="cancel-book-settings"]')?.addEventListener('click', () => {
              bookSettingsModal.style.display = 'none';
          });

          // Auto text color based on background color
          const colorInput = bookSettingsForm.querySelector('input[type="color"]');
          const colorTextInput = bookSettingsForm.querySelector('input[type="text"][pattern]');
          
          function getTextColorForBackground(hexColor) {
              // Convert hex to RGB
              const r = parseInt(hexColor.substr(1, 2), 16);
              const g = parseInt(hexColor.substr(3, 2), 16);
              const b = parseInt(hexColor.substr(5, 2), 16);
              
              // Calculate relative luminance (ITU-R BT.709)
              const luminance = (0.2126 * r + 0.7152 * g + 0.0722 * b) / 255;
              
              // Return black for light backgrounds, white for dark backgrounds
              return luminance > 0.5 ? 'black' : 'white';
          }
          
          function updateColorPreview(color) {
              const textColor = getTextColorForBackground(color);
              
              // Update color picker container background and text
              const colorPickerContainer = bookSettingsForm.querySelector('.color-picker-container');
              if (colorPickerContainer) {
                  colorPickerContainer.style.backgroundColor = color;
                  colorPickerContainer.style.padding = '0.5rem';
                  colorPickerContainer.style.borderRadius = '8px';
                  
                  // Update text input color
                  if (colorTextInput) {
                      colorTextInput.style.color = textColor;
                  }
              }
          }
          
          if (colorInput && colorTextInput) {
              colorInput.addEventListener('input', (e) => {
                  const color = e.target.value;
                  colorTextInput.value = color;
                  updateColorPreview(color);
              });
              
              colorTextInput.addEventListener('input', (e) => {
                  const color = e.target.value.trim();
                  if (/^#[0-9A-Fa-f]{6}$/.test(color)) {
                      colorInput.value = color;
                      updateColorPreview(color);
                  }
              });
              
              // Set initial preview
              updateColorPreview(colorInput.value);
          }
      }
  }
  {{end}}

  // --- INITIALIZATION ---
  fetchBook();
  prevBtn.addEventListener('click', goToPrevSpread);
  nextBtn.addEventListener('click', goToNextSpread);
  addPageBtn.addEventListener('click', handleAddPage);
});
</script>
</body>
</html>