<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PageFlipper</title>
  <style>
    /* General styles from globals.css and layout */
    :root {
      --background: 220 25% 10%;
      --foreground: 220 20% 90%;
      --card: 220 25% 15%;
      --card-foreground: 220 20% 90%;
      --primary: 210 80% 60%;
      --primary-foreground: 210 80% 10%;
      --accent: 200 90% 50%;
      --accent-foreground: 200 90% 95%;
      --border: 220 25% 30%;
      --muted-foreground: 220 15% 55%;
      --highlight-yellow: hsla(55, 100%, 50%, 0.4);
      --highlight-pink: hsla(330, 100%, 50%, 0.4);
      --highlight-blue: hsla(210, 100%, 50%, 0.4);
      --highlight-green: hsla(130, 100%, 50%, 0.4);
    }
    body {
      font-family: 'Literata', serif;
      background-color: hsl(var(--background));
      color: hsl(var(--foreground));
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: Arial, Helvetica, sans-serif;
      overflow-x: hidden;
    }
    main {
      display: flex;
      min-height: 100vh;
      width: 100%;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 1rem 0; /* Add some vertical padding */
    }
    .pageflipper-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-family: 'Literata', serif;
      width: 100%;
    }

    /* Editor Toolbar */
    .editor-toolbar {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        padding: 0.5rem 1rem;
        background-color: hsl(var(--card));
        border: 1px solid hsl(var(--border));
        border-radius: 8px;
        margin-bottom: 1rem;
        box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
    }
    .toolbar-button {
        background: none;
        border: none;
        color: hsl(var(--foreground));
        cursor: pointer;
        padding: 0.5rem;
        border-radius: 4px;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    .toolbar-button:hover {
        background-color: hsl(var(--border));
    }
    .toolbar-button.active {
        background-color: hsl(var(--primary));
        color: hsl(var(--primary-foreground));
    }
    .toolbar-button svg {
        width: 1rem;
        height: 1rem;
    }


    /* page-flipper.css */
    .book-container {
      width: 90vw;
      height: 80vh;
      max-width: 1200px;
      max-height: 800px;
      position: relative;
      perspective: 2500px;
      transition: transform 0.5s;
    }
    .book-container.closed {
        transform: scaleX(0.7);
    }
    .sheet {
      position: absolute;
      width: 50%;
      height: 100%;
      top: 0;
      left: 50%;
      transform-origin: left center;
      transition: transform 1s ease-in-out;
      transform-style: preserve-3d;
      box-shadow: 0 4px 20px rgba(0,0,0,0.2);
    }
    .sheet.flipped {
      transform: rotateY(-180deg);
    }
    .page {
      position: absolute;
      width: 100%;
      height: 100%;
      backface-visibility: hidden;
      background-color: hsl(var(--card));
      border: 1px solid hsl(var(--border));
      overflow: hidden;
    }
    .page-front {
      border-radius: 0 8px 8px 0;
    }
    .page-back {
      transform: rotateY(180deg);
      border-radius: 8px 0 0 8px;
    }
    .page.is-cover, .page.is-back-cover {
      background-color: hsl(var(--accent));
      color: hsl(var(--accent-foreground));
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
    }
    .page.is-cover .page-content .editable-area {
        color: hsl(var(--accent-foreground));
        text-align: center;
        font-size: 1.2rem;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start;
        gap: 0.8rem;
        height: 100%;
        width: 100%;
        padding-top: 5px;
    }
    .page.is-cover .cover-author {
        font-size: 0.9rem;
        opacity: 0.85;
        margin-bottom: 0.5rem;
        align-self: flex-start;
        margin-left: 1rem;
    }
    .page.is-cover .cover-title {
        font-size: 1.8rem;
        font-weight: 700;
        margin: 0;
        text-align: center;
        width: 100%;
        text-transform: uppercase;
    }
    .page.is-cover .cover-image {
        width: 100%;
        height: 250px;
        object-fit: cover;
        border-radius: 8px;
        box-shadow: 0 8px 20px rgba(15, 23, 42, 0.3);
    }
    .page.is-cover .cover-description {
        font-size: 0.8rem;
        line-height: 1.4;
        opacity: 0.9;
        max-width: 80%;
        text-align: center;
    }
    .page-content {
      padding: 2rem;
      padding-bottom: 3rem; /* Space for page number */
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      box-sizing: border-box;
      overflow: hidden; /* No scroll on page-content */
      position: relative;
    }
    .page-number-left {
      position: absolute;
      bottom: 1rem;
      left: 1.5rem;
      font-size: 0.875rem;
      color: hsl(var(--muted-foreground));
      z-index: 10; /* Above editable area */
      pointer-events: none; /* Don't block clicks */
    }
    .page-number-right {
      position: absolute;
      bottom: 1rem;
      right: 1.5rem;
      font-size: 0.875rem;
      color: hsl(var(--muted-foreground));
      z-index: 10; /* Above editable area */
      pointer-events: none; /* Don't block clicks */
    }
    .editable-area {
      line-height: 1.6;
      width: 100%;
      flex: 1; /* Take remaining space */
      background-color: hsl(var(--card)); /* Solid background */
      border: 2px solid hsl(var(--accent));
      border-radius: 4px;
      position: relative;
      resize: none;
      color: hsl(var(--foreground));
      font-size: 1em;
      padding: 0.5rem; /* Padding inside border */
      padding-bottom: 2rem; /* Extra space at bottom */
      white-space: pre-wrap;
      word-wrap: break-word;
      outline: none;
      overflow-y: auto; /* Scroll on editable area only */
      overflow-x: hidden;
      box-shadow: 0 0 0 0 hsl(var(--accent));
      animation: borderGlow 3s ease-in-out infinite;
    }
    
    /* No border for cover pages */
    .page.is-cover .editable-area,
    .page.is-back-cover .editable-area {
      background-color: transparent; /* Cover uses page background */
      border: none;
      box-shadow: none;
      animation: none;
    }
    
    @keyframes borderGlow {
      0%, 100% {
        border-color: hsl(var(--accent));
        box-shadow: 0 0 5px hsl(var(--accent));
      }
      33% {
        border-color: hsl(210, 100%, 60%);
        box-shadow: 0 0 5px hsl(210, 100%, 60%);
      }
      66% {
        border-color: hsl(280, 100%, 60%);
        box-shadow: 0 0 5px hsl(280, 100%, 60%);
      }
    }
    /* Inline styles from Quill editor are preserved */
    .editable-area img {
        max-width: 100%;
        height: auto;
        border-radius: 4px;
        cursor: pointer;
        user-select: none;
        -webkit-user-select: none;
    }
    .editable-area[contenteditable="false"] img {
        pointer-events: none;
        cursor: default;
    }
    .editable-area table {
      width: 100%;
      border-collapse: collapse;
      margin: 1em 0;
    }
    .editable-area th, .editable-area td {
      border: 1px solid hsl(var(--border));
      padding: 8px;
      min-width: 50px;
    }
    .editable-area th {
      background-color: hsl(var(--background));
    }
    .editable-area:empty:before{
      content: attr(placeholder);
      pointer-events: none;
      display: block; /* For Firefox */
      color: hsl(var(--muted-foreground));
    }
    mark {
        position: relative;
        cursor: pointer;
        background-color: var(--highlight-yellow);
        border-radius: 3px;
        padding: 0.1em 0.3em;
        text-align: center;
    }
    mark:hover .highlight-note {
      display: block;
    }
    .highlight-note {
      display: none;
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background-color: #333;
      color: white;
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 0.8rem;
      width: 200px;
      margin-bottom: 8px;
      z-index: 100;
      white-space: pre-wrap;
    }

    /* Button styles */
    .button {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      white-space: nowrap;
      border-radius: 0.375rem;
      font-size: 0.875rem;
      line-height: 1.25rem;
      font-weight: 500;
      transition: background-color 150ms;
      height: 2.5rem;
      padding: 0.5rem 1rem;
      cursor: pointer;
      border: none;
      background-color: hsl(var(--primary));
      color: hsl(var(--primary-foreground));
      box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
    }
    .button.icon-button {
      padding: 0.5rem;
      width: 2.5rem;
    }
    .button:hover {
      background-color: hsl(var(--primary) / 0.9);
    }
    .button:disabled {
      pointer-events: none;
      opacity: 0.5;
    }
    .button svg {
      width: 1rem;
      height: 1rem;
    }
    .controls {
      margin-top: 2rem;
      display: flex;
      width: 90%;
      max-width: 1200px;
      justify-content: center;
      align-items: center;
      gap: 1rem;
    }
    .nav-buttons {
      display: flex;
      gap: 1rem;
      align-items: center;
    }

    /* Highlight Popover */
    #highlight-popover {
        position: fixed;
        background-color: #333;
        border-radius: 6px;
        padding: 4px;
        display: none;
        gap: 4px;
        z-index: 1000;
        box-shadow: 0 4px 12px rgba(0,0,0,0.4);
    }
    #highlight-popover button {
        background: none;
        border: 1px solid #555;
        color: white;
        border-radius: 4px;
        padding: 4px 8px;
        cursor: pointer;
        font-size: 0.8rem;
    }
    #highlight-popover button:hover {
        background: #555;
    }

    /* Generic Modal Styles */
    .modal-overlay {
        position: fixed;
        inset: 0;
        background: rgba(0,0,0,0.7);
        z-index: 1000;
        display: none;
    }
    .modal {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: hsl(var(--card));
        color: hsl(var(--card-foreground));
        padding: 2rem;
        border-radius: 8px;
        box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        z-index: 1001;
        width: 350px;
        display: none;
        box-sizing: border-box;
    }
    .modal h3 {
        margin-top: 0;
    }
    .modal label {
        display: block;
        margin-top: 1rem;
        color: hsl(var(--muted-foreground));
        font-size: 0.9rem;
    }
    .modal input[type="text"],
    .modal input[type="number"],
    .modal input[type="color"],
    .modal textarea {
        width: 100%;
        background-color: hsl(var(--background));
        color: hsl(var(--foreground));
        border: 1px solid hsl(var(--border));
        border-radius: 4px;
        padding: 8px;
        margin-top: 0.5rem;
        box-sizing: border-box;
    }
    .modal-buttons {
        margin-top: 1.5rem;
        display: flex;
        justify-content: flex-end;
        gap: 1rem;
    }

    /* Highlight Modal Specifics */
    #highlight-modal textarea {
        min-height: 80px;
    }
    .color-picker {
        display: flex;
        gap: 10px;
        margin-top: 1rem;
    }
    .color-box {
        width: 30px;
        height: 30px;
        border-radius: 50%;
        cursor: pointer;
        border: 2px solid transparent;
        transition: border-color 0.2s;
    }
    .color-box.selected {
        border-color: hsl(var(--foreground));
    }
    
    /* Book Settings Modal */
    .modal-large {
        width: 600px !important;
        max-width: 95vw;
    }
    
    .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1.5rem;
        padding-bottom: 1rem;
        border-bottom: 1px solid rgba(148, 163, 184, 0.2);
    }
    
    .modal-header h2 {
        margin: 0;
        font-size: 1.5rem;
        color: #e2e8f0;
    }
    
    .modal-close {
        background: none;
        border: none;
        color: #94a3b8;
        font-size: 2rem;
        cursor: pointer;
        padding: 0;
        width: 32px;
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 8px;
        transition: all 0.2s;
    }
    
    .modal-close:hover {
        background: rgba(148, 163, 184, 0.15);
        color: #e2e8f0;
    }
    
    .book-settings-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 2rem;
    }
    
    .book-settings-preview {
        display: flex;
        flex-direction: column;
        gap: 1rem;
    }
    
    .settings-preview-card {
        background: rgba(15, 23, 42, 0.6);
        border: 1px solid rgba(148, 163, 184, 0.2);
        border-radius: 12px;
        padding: 1.25rem;
        display: flex;
        flex-direction: column;
        gap: 1rem;
    }
    
    .settings-preview-author {
        color: #94a3b8;
        font-size: 0.9rem;
        font-weight: 500;
        padding-bottom: 0.75rem;
        border-bottom: 1px solid rgba(148, 163, 184, 0.2);
    }
    
    .settings-preview-cover {
        width: 100%;
        height: 220px;
        border-radius: 12px;
        overflow: hidden;
        background: rgba(15, 23, 42, 0.6);
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
    }
    
    .settings-preview-placeholder {
        font-size: 5rem;
        opacity: 0.3;
    }
    
    .settings-preview-cover img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        position: absolute;
        top: 0;
        left: 0;
    }
    
    .settings-preview-info {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
    }
    
    .settings-preview-info h4 {
        margin: 0;
        font-size: 1.25rem;
        color: #e2e8f0;
    }
    
    .settings-preview-info p {
        margin: 0;
        color: #cbd5e1;
        font-size: 0.9rem;
        line-height: 1.5;
    }
    
    .color-picker-container {
        display: flex;
        gap: 0.75rem;
        align-items: center;
    }
    
    .color-picker-container input[type="color"] {
        width: 60px;
        height: 40px;
        border: 1px solid rgba(148, 163, 184, 0.3);
        border-radius: 8px;
        cursor: pointer;
        background: transparent;
        padding: 2px;
    }
    
    .color-picker-container input[type="text"] {
        flex: 1;
        font-family: 'Courier New', monospace;
        text-transform: uppercase;
    }
    
    @media (max-width: 768px) {
        .book-settings-grid {
            grid-template-columns: 1fr;
        }
    }
    
    #loader {
        font-size: 1.5rem;
        color: hsl(var(--foreground));
    }
     @media (max-width: 767px) {
      .pageflipper-container {
        padding: 0;
      }

      /* Hide desktop controls */
      .controls {
        display: none;
      }
      
      .editor-toolbar {
        width: 90%;
        justify-content: center;
      }

      /* Convert the book to a horizontal scroll container */
      .book-container {
        display: flex;
        overflow-x: auto;
        overflow-y: hidden;
        scroll-snap-type: x mandatory;
        perspective: none;
        width: 100vw;
        height: 85vh;
        max-width: none;
        max-height: none;
        position: static;
        box-shadow: none;
        transform: none !important; /* Override hover/closed transforms */
      }

      /* Each sheet becomes a full-width page container */
      .sheet {
        position: static;
        display: flex;
        flex-shrink: 0;
        width: 100%;
        height: 100%;
        transform: none !important; /* Override flip transform */
        box-shadow: none;
      }

      /* Each page becomes a scroll-snap item */
      .page {
        position: relative; /* Change from absolute */
        flex-shrink: 0;
        width: 100%;
        height: 100%;
        scroll-snap-align: center;
        border-radius: 0 !important;
        transform: none !important; /* Override backface transform */
        backface-visibility: visible;
        border-left: none;
        border-right: none;
        display: block; /* Ensure it's not hidden */
      }
      
      .page-content {
        padding: 1.5rem 1rem;
      }

      .page-number-left, .page-number-right {
        bottom: 0.5rem;
        background: hsla(var(--background), 0.7);
        padding: 0.2rem 0.4rem;
        border-radius: 4px;
      }
      .page-number-left { left: 0.5rem; }
      .page-number-right { right: 0.5rem; }
    }
  </style>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossOrigin="anonymous" />
  <link href="https://fonts.googleapis.com/css2?family=Literata:ital,opsz,wght@0,7..72,400;0,7..72,700;1,7..72,400;1,7..72,700&display=swap" rel="stylesheet" />
</head>
<body>
  <main>
    <div id="loader">Loading your book...</div>
    <div class="pageflipper-container" style="display: none;">
      <div class="editor-toolbar">
        <button id="bold-btn" class="toolbar-button" title="Bold (Ctrl+B)">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 4h8a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"></path><path d="M6 12h9a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"></path></svg>
        </button>
        <button id="italic-btn" class="toolbar-button" title="Italic (Ctrl+I)">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="19" y1="4" x2="10" y2="4"></line><line x1="14" y1="20" x2="5" y2="20"></line><line x1="15" y1="4" x2="9" y2="20"></line></svg>
        </button>
        <button id="underline-btn" class="toolbar-button" title="Underline (Ctrl+U)">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 3v7a6 6 0 0 0 6 6 6 6 0 0 0 6-6V3"></path><line x1="4" y1="21" x2="20" y2="21"></line></svg>
        </button>
        <button id="image-btn" class="toolbar-button" title="Insert Image">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0-0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>
        </button>
        <button id="fontsize-btn" class="toolbar-button" title="C·ª° ch·ªØ">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="4 7 4 4 7 4"></polyline><polyline points="20 7 20 4 17 4"></polyline><polyline points="14 20 14 17 17 17"></polyline><polyline points="10 20 10 17 7 17"></polyline><line x1="7" y1="12" x2="17" y2="12"></line></svg>
        </button>
        <button id="fontcolor-btn" class="toolbar-button" title="M√†u ch·ªØ">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 14c-2.5 0-4.5-2-4.5-4.5S9.5 5 12 5s4.5 2 4.5 4.5-2 4.5-4.5 4.5zm0-2c-1.38 0-2.5-1.12-2.5-2.5S10.62 7 12 7s2.5 1.12 2.5 2.5S13.38 12 12 12zm0 8c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm0-14c-3.31 0-6 2.69-6 6s2.69 6 6 6 6-2.69 6-6-2.69-6-6-6z"/><path d="M20.71 14.71l-1.42 1.42c-.39.39-1.02.39-1.41 0l-1.17-1.17c-.39-.39-.39-1.02 0-1.41l1.42-1.42c.39-.39 1.02-.39 1.41 0l1.17 1.17c.39.39.39 1.02 0 1.41z"/></svg>
        </button>
        <button id="table-btn" class="toolbar-button" title="Insert Table">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="3" y1="9" x2="21" y2="9"></line><line x1="3" y1="15" x2="21" y2="15"></line><line x1="9" y1="3" x2="9" y2="21"></line><line x1="15" y1="3" x2="15" y2="21"></line></svg>
        </button>
        <input type="file" id="image-upload" accept="image/*" style="display: none;" />
      </div>

      <div id="book-container" class="book-container">
        <!-- Sheets will be generated here by JavaScript -->
      </div>
      <div class="controls">
        <div class="nav-buttons">
          <button id="prev-btn" class="button">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m12 19-7-7 7-7"/><path d="M19 12H5"/></svg>
            Trang tr∆∞·ªõc
          </button>
          
          <button id="next-btn" class="button">
            Trang sau
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M5 12h14"/><path d="m12 5 7 7-7 7"/></svg>
          </button>
        </div>

        {{if .IsAuthor}}
        <button id="book-settings-btn" class="button">
          ‚öôÔ∏è C√†i ƒë·∫∑t s√°ch
        </button>
        {{end}}

        <button id="add-page-btn" class="button icon-button">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>
        </button>
      </div>
    </div>
  </main>

  <!-- Highlight Popover -->
  <div id="highlight-popover">
    <button id="popover-highlight-btn">Highlight</button>
    <button id="popover-remove-highlight-btn">X√≥a highlight</button>
  </div>

  <!-- Highlight Modal -->
  <div id="highlight-modal-overlay" class="modal-overlay"></div>
  <div id="highlight-modal" class="modal">
      <h3>Th√™m ch√∫ th√≠ch</h3>
      <textarea id="highlight-note-input" placeholder="Enter your explanation here..."></textarea>
      
      <h3>Ch·ªçn m√†u</h3>
      <div class="color-picker">
          <div class="color-box selected" style="background-color: var(--highlight-yellow);" data-color="var(--highlight-yellow)"></div>
          <div class="color-box" style="background-color: var(--highlight-pink);" data-color="var(--highlight-pink)"></div>
          <div class="color-box" style="background-color: var(--highlight-blue);" data-color="var(--highlight-blue)"></div>
          <div class="color-box" style="background-color: var(--highlight-green);" data-color="var(--highlight-green)"></div>
      </div>
      
      <div class="modal-buttons">
          <button id="highlight-modal-cancel-btn" class="button" style="background-color: hsl(var(--border)); color: hsl(var(--foreground));">H·ªßy</button>
          <button id="highlight-modal-remove-btn" class="button" style="background-color: #ef4444; color: white; display: none;">X√≥a m√†u</button>
          <button id="highlight-modal-save-btn" class="button">L∆∞u</button>
      </div>
  </div>

  <!-- Generic Input Modal -->
  <div id="input-modal-overlay" class="modal-overlay"></div>
  <div id="input-modal" class="modal">
      <h3 id="input-modal-title">Nh·∫≠p gi√° tr·ªã</h3>
      <div id="input-modal-content"></div>
      <div class="modal-buttons">
          <button id="input-modal-cancel-btn" class="button" style="background-color: hsl(var(--border)); color: hsl(var(--foreground));">Cancel</button>
          <button id="input-modal-save-btn" class="button">OK</button>
      </div>
  </div>

  <!-- Book Settings Modal -->
  {{if .IsAuthor}}
  <div id="book-settings-modal" class="modal" style="display: none;">
      <div class="modal-content modal-large">
          <div class="modal-header">
              <h2>‚öôÔ∏è C√†i ƒë·∫∑t s√°ch</h2>
              <button type="button" class="modal-close" data-action="close-book-settings">√ó</button>
          </div>
          <form id="book-settings-form" class="stack">
              <label>
                  Ti√™u ƒë·ªÅ s√°ch
                  <input type="text" name="title" value="{{.Book.Title}}" placeholder="Nh·∫≠p ti√™u ƒë·ªÅ s√°ch" required>
              </label>
              <label>
                  M√¥ t·∫£ ng·∫Øn
                  <textarea name="description" rows="4" placeholder="T√≥m t·∫Øt n·ªôi dung s√°ch...">{{.Book.Description}}</textarea>
              </label>
              <label>
                  ·∫¢nh b√¨a (URL)
                  <input type="url" name="cover_url" value="{{.Book.CoverURL}}" placeholder="https://example.com/cover.jpg">
                  <small style="color: #94a3b8; font-size: 0.85rem;">ƒê·ªÉ tr·ªëng n·∫øu mu·ªën d√πng m√†u n·ªÅn</small>
              </label>
              <label>
                  M√†u b√¨a s√°ch
                  <div class="color-picker-container">
                      <input type="color" name="cover_color" value="{{if .Book.CoverColor}}{{.Book.CoverColor}}{{else}}#1e293b{{end}}">
                      <input type="text" value="{{if .Book.CoverColor}}{{.Book.CoverColor}}{{else}}#1e293b{{end}}" placeholder="#1e293b" pattern="^#[0-9A-Fa-f]{6}$">
                  </div>
                  <small style="color: #94a3b8; font-size: 0.85rem;">Ch·ªçn m√†u n·ªÅn cho b√¨a s√°ch khi kh√¥ng c√≥ ·∫£nh</small>
              </label>
              <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                  <input type="checkbox" name="published" {{if .Book.Published}}checked{{end}} style="cursor: pointer;">
                  <span>Xu·∫•t b·∫£n s√°ch (cho ph√©p ng∆∞·ªùi kh√°c xem)</span>
              </label>
              <div class="form-actions">
                  <button type="button" class="btn ghost" data-action="cancel-book-settings">H·ªßy</button>
                  <button type="submit" class="btn primary">üíæ L∆∞u thay ƒë·ªïi</button>
              </div>
          </form>
      </div>
  </div>
  {{end}}


  <script>
    document.addEventListener('DOMContentLoaded', () => {
      // --- CONFIGURATION ---
      function getBookIdFromUrl() {
          // URL format: /books/:id/read
          const pathParts = window.location.pathname.split('/').filter(p => p);
          if (pathParts[0] === 'books' && pathParts.length >= 3 && pathParts[2] === 'read') {
              const bookId = pathParts[1];
              if (bookId && !isNaN(parseInt(bookId, 10))) {
                  return parseInt(bookId, 10);
              }
          }
          console.warn("Could not find book ID in URL, falling back to 1. URL should be like /books/1/read");
          return 1; 
      }
      const BOOK_ID = getBookIdFromUrl();

      const FLIP_DURATION = 1000;
      const DEBOUNCE_DELAY = 1500; // ms to wait after user stops typing to save

      // --- STATE ---
      let book = null; // { id, title, pages: [...] }
      let currentSpread = 0;
      let isFlipping = false;
      let currentSelection = null;
      let activeEditableArea = null;
      let selectedImage = null;
      let debounceTimeout = null;
      let isAuthenticated = false; // Track if user is logged in

      // --- DOM ELEMENTS ---
      const loader = document.getElementById('loader');
      const pageFlipperContainer = document.querySelector('.pageflipper-container');
      const bookContainer = document.getElementById('book-container');
      const prevBtn = document.getElementById('prev-btn');
      const nextBtn = document.getElementById('next-btn');
      const addPageBtn = document.getElementById('add-page-btn');
      const editorToolbar = document.querySelector('.editor-toolbar');
      
      // Popovers and Modals
      const highlightPopover = document.getElementById('highlight-popover');
      const popoverHighlightBtn = document.getElementById('popover-highlight-btn');
      const popoverRemoveHighlightBtn = document.getElementById('popover-remove-highlight-btn');
      const highlightModalOverlay = document.getElementById('highlight-modal-overlay');
      const highlightModal = document.getElementById('highlight-modal');
      const noteInput = document.getElementById('highlight-note-input');
      const colorPicker = document.querySelector('.color-picker');
      const highlightModalCancelBtn = document.getElementById('highlight-modal-cancel-btn');
      const highlightModalRemoveBtn = document.getElementById('highlight-modal-remove-btn');
      const highlightModalSaveBtn = document.getElementById('highlight-modal-save-btn');
      const inputModalOverlay = document.getElementById('input-modal-overlay');
      const inputModal = document.getElementById('input-modal');
      const inputModalTitle = document.getElementById('input-modal-title');
      const inputModalContent = document.getElementById('input-modal-content');
      const inputModalCancelBtn = document.getElementById('input-modal-cancel-btn');
      const inputModalSaveBtn = document.getElementById('input-modal-save-btn');
      let inputModalCallback = null;

      // Toolbar
      const boldBtn = document.getElementById('bold-btn');
      const italicBtn = document.getElementById('italic-btn');
      const underlineBtn = document.getElementById('underline-btn');
      const imageBtn = document.getElementById('image-btn');
      const imageUpload = document.getElementById('image-upload');
      const fontsizeBtn = document.getElementById('fontsize-btn');
      const fontcolorBtn = document.getElementById('fontcolor-btn');
      const tableBtn = document.getElementById('table-btn');

      // --- API FUNCTIONS ---
      async function fetchBook() {
        try {
          const response = await fetch(`/books/${BOOK_ID}/read`, {
            headers: {
              'Accept': 'application/json'
            }
          });
          if (!response.ok) {
            let errorDetails = `HTTP error! status: ${response.status}`;
            try {
                const errorJson = await response.clone().json();
                errorDetails = errorJson.error || JSON.stringify(errorJson);
            } catch (e) {
                 const text = await response.clone().text();
                 errorDetails += ' - Response is not valid JSON: ' + text.substring(0, 200);
            }
            throw new Error(errorDetails);
          }
          book = await response.json();
          if (!book.pages) {
            book.pages = [];
          }
          book.pages.sort((a, b) => a.page_number - b.page_number);
          
          // Check if user is authenticated (book has user_id or is_author flag)
          isAuthenticated = book.is_author || false;
          
          // Hide editor toolbar and add page button if not author
          if (!isAuthenticated) {
              addPageBtn.style.display = 'none';
              editorToolbar.style.display = 'none';
          }
          
          loader.style.display = 'none';
          pageFlipperContainer.style.display = 'flex';
          await renderBook();
        } catch (error) {
          console.error("Failed to load book:", error);
          loader.textContent = `Error loading book. Please check if the backend is running. Details: ${error.message}`;
        }
      }

      async function updatePage(pageId, pageData) {
        try {
          const response = await fetch(`/books/${BOOK_ID}/pages/${pageId}/edit`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(pageData)
          });
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          console.log(`Page ${pageId} updated successfully.`);
        } catch(error) {
          console.error(`Failed to update page ${pageId}:`, error);
        }
      }
      
      async function createPage(pageData) {
          try {
              const response = await fetch(`/books/${BOOK_ID}/pages`, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify(pageData)
              });
              if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
              const newPage = await response.json();
              console.log("New page created:", newPage);
              return newPage;
          } catch(error) {
              console.error("Failed to create page:", error);
              return null;
          }
      }

      async function saveHighlight(pageId, highlightData) {
          try {
              const response = await fetch(`/books/${BOOK_ID}/pages/${pageId}/highlights`, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify(highlightData)
              });
              if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
              const highlight = await response.json();
              console.log("Highlight saved:", highlight);
              return highlight;
          } catch(error) {
              console.error("Failed to save highlight:", error);
              return null;
          }
      }

      async function fetchHighlights(pageId) {
          try {
              const response = await fetch(`/books/${BOOK_ID}/pages/${pageId}/highlights`);
              if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
              const highlights = await response.json();
              return highlights;
          } catch(error) {
              console.error("Failed to fetch highlights:", error);
              return [];
          }
      }

      async function deleteHighlight(pageId, highlightId) {
          try {
              const response = await fetch(`/books/${BOOK_ID}/pages/${pageId}/highlights/${highlightId}`, {
                  method: 'DELETE'
              });
              if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
              console.log("Highlight deleted:", highlightId);
              return true;
          } catch(error) {
              console.error("Failed to delete highlight:", error);
              return false;
          }
      }

      // --- CORE LOGIC ---
      async function loadHighlightsForPage(pageId, editableElement) {
          if (pageId === 'cover' || pageId === 'back-cover' || pageId === 'placeholder' || isNaN(parseInt(pageId))) {
              return;
          }

          // Try to load highlights (may fail if not authenticated, that's ok)
          let highlights = [];
          try {
              highlights = await fetchHighlights(pageId);
          } catch (error) {
              // Silently fail if not authenticated - highlights just won't show
              console.log("Could not load highlights (may not be authenticated)");
              return;
          }

          if (!highlights || highlights.length === 0) return;

          // Apply highlights to the content
          const content = editableElement.textContent;
          
          // Sort highlights by start_offset descending to apply from end to start
          highlights.sort((a, b) => b.start_offset - a.start_offset);
          
          let newHTML = editableElement.innerHTML;
          
          for (const highlight of highlights) {
              try {
                  // Create a temporary div to work with the content
                  const tempDiv = document.createElement('div');
                  tempDiv.innerHTML = newHTML;
                  const textContent = tempDiv.textContent;
                  
                  // Find the text to highlight
                  const beforeText = textContent.substring(0, highlight.start_offset);
                  const highlightText = textContent.substring(highlight.start_offset, highlight.end_offset);
                  const afterText = textContent.substring(highlight.end_offset);
                  
                  // Create mark element
                  const mark = document.createElement('mark');
                  mark.style.backgroundColor = highlight.color;
                  mark.setAttribute('data-highlight-id', highlight.id);
                  mark.textContent = highlightText;
                  
                  if (highlight.note) {
                      const noteSpan = document.createElement('span');
                      noteSpan.className = 'highlight-note';
                      // Show user name and note
                      const userName = highlight.user_name || 'Anonymous';
                      noteSpan.textContent = `${userName}: ${highlight.note}`;
                      mark.insertBefore(noteSpan, mark.firstChild);
                  }
                  
                  // Reconstruct HTML
                  tempDiv.textContent = beforeText;
                  tempDiv.appendChild(mark);
                  tempDiv.appendChild(document.createTextNode(afterText));
                  
                  newHTML = tempDiv.innerHTML;
              } catch (e) {
                  console.error("Error applying highlight:", e, highlight);
              }
          }
          
          editableElement.innerHTML = newHTML;
      }

      function getTextColorForBackground(hexColor) {
          // Convert hex to RGB
          const r = parseInt(hexColor.substr(1, 2), 16);
          const g = parseInt(hexColor.substr(3, 2), 16);
          const b = parseInt(hexColor.substr(5, 2), 16);
          
          // Calculate relative luminance (ITU-R BT.709)
          const luminance = (0.2126 * r + 0.7152 * g + 0.0722 * b) / 255;
          
          // Return black for light backgrounds, white for dark backgrounds
          return luminance > 0.5 ? '#000000' : '#ffffff';
      }

      async function renderBook() {
        bookContainer.innerHTML = '';
        if (!book) {
            console.error("Book data is not available for rendering.");
            return;
        }

        // 1. Create a clean array of actual content pages from the API
        const contentPages = book.pages ? [...book.pages] : [];

        // 2. Ensure content pages are even for spread layout
        if (contentPages.length % 2 !== 0) {
            // CREATE A REAL PAGE instead of placeholder
            const lastPageNum = contentPages.length > 0 ? contentPages[contentPages.length - 1].page_number : 0;
            
            // Create the missing page in database
            const newPageData = { page_number: lastPageNum + 1, title: `Page ${lastPageNum + 1}`, content: '' };
            const createdPage = await createPage(newPageData);
            if (createdPage) {
                book.pages.push(createdPage);
                contentPages.push(createdPage);
                console.log("Created missing page to make even layout:", createdPage);
            } else {
                // Fallback to placeholder if creation fails
                contentPages.push({
                    id: 'placeholder', 
                    page_number: lastPageNum + 1, 
                    content: '',
                    title: ''
                });
            }
        }
        
        const finalPages = [...contentPages];

        // 3. Add Cover and Back Cover
        const coverContent = `
            <div class="cover-author">${book.author_name || '·∫®n danh'}</div>
            <h1 class="cover-title">${book.title || 'Book Title'}</h1>
            ${book.cover_url ? `<img class="cover-image" src="${book.cover_url}" alt="Cover Image" onerror="this.style.display='none'">` : ''}
            ${book.description ? `<div class="cover-description">${book.description}</div>` : ''}
        `;
        finalPages.unshift({id: 'cover', page_number: 0, content: coverContent});
        
        const quotes = [
            "H·ªçc, h·ªçc n·ªØa, h·ªçc m√£i.", "ƒêi m·ªôt ng√†y ƒë√†ng, h·ªçc m·ªôt s√†ng kh√¥n.",
            "C√≥ c√¥ng m√†i s·∫Øt, c√≥ ng√†y n√™n kim.", "Kh√¥ng th·∫ßy ƒë·ªë m√†y l√†m n√™n.",
            "Mu·ªën bi·∫øt ph·∫£i h·ªèi, mu·ªën gi·ªèi ph·∫£i h·ªçc."
        ];
        const randomQuote = quotes[Math.floor(Math.random() * quotes.length)];
        finalPages.push({id: 'back-cover', page_number: -1, content: randomQuote});

        const numSheets = Math.ceil(finalPages.length / 2);

        for (let index = 0; index < numSheets; index++) {
          const sheet = document.createElement('div');
          const isFlipped = index < currentSpread;
          sheet.className = 'sheet';
          if (isFlipped) {
            sheet.classList.add('flipped');
          }
          sheet.style.zIndex = isFlipped ? index + 1 : numSheets - index;
          
          const frontPageData = finalPages[index * 2];
          const backPageData = finalPages[index * 2 + 1];

          // --- Front Page ---
          if (frontPageData) {
              const pageFront = document.createElement('div');
              const isCover = frontPageData.id === 'cover';
              pageFront.className = 'page page-front';
              if (isCover) {
                  pageFront.classList.add('is-cover');
                  // Apply cover color if available
                  if (book.cover_color) {
                      pageFront.style.backgroundColor = book.cover_color;
                      
                      // Auto text color based on background
                      const textColor = getTextColorForBackground(book.cover_color);
                      pageFront.style.color = textColor;
                      
                      // Apply text color to all child elements after they're created
                      setTimeout(() => {
                          const author = pageFront.querySelector('.cover-author');
                          const title = pageFront.querySelector('.cover-title');
                          const description = pageFront.querySelector('.cover-description');
                          
                          if (author) author.style.color = textColor;
                          if (title) title.style.color = textColor;
                          if (description) description.style.color = textColor;
                      }, 0);
                  }
              }

              const pageContentFront = document.createElement('div');
              pageContentFront.className = 'page-content';
              
              const editableFront = document.createElement('div');
              // Only make editable if user is authenticated and not cover
              editableFront.contentEditable = String(isAuthenticated && !isCover);
              editableFront.className = 'editable-area';
              editableFront.setAttribute('data-page-id', frontPageData.id);
              editableFront.innerHTML = frontPageData.content || '';
              
              if (!isCover) {
                if (isAuthenticated) {
                  editableFront.addEventListener('input', handlePageInput);
                  editableFront.setAttribute('placeholder', `Start writing on page ${frontPageData.page_number}...`);
                }
                // Load highlights for this page
                loadHighlightsForPage(frontPageData.id, editableFront);
              }
              editableFront.addEventListener('focus', () => { activeEditableArea = editableFront; });

              pageContentFront.appendChild(editableFront);

              if(!isCover) {
                const pageNumFront = document.createElement('div');
                pageNumFront.className = 'page-number-right';
                pageNumFront.textContent = frontPageData.page_number;
                pageContentFront.appendChild(pageNumFront);
              }
              pageFront.appendChild(pageContentFront);
              sheet.appendChild(pageFront);
          }
          
          // --- Back Page ---
          if (backPageData) {
              const pageBack = document.createElement('div');
              const isBackCover = backPageData.id === 'back-cover';
              pageBack.className = 'page page-back';
              if (isBackCover) {
                  pageBack.classList.add('is-back-cover');
                  // Apply cover color to back cover as well
                  if (book.cover_color) {
                      pageBack.style.backgroundColor = book.cover_color;
                      
                      // Auto text color based on background
                      const textColor = getTextColorForBackground(book.cover_color);
                      pageBack.style.setProperty('color', textColor, 'important');
                      
                      // Apply to child elements after they're created
                      setTimeout(() => {
                          const editableArea = pageBack.querySelector('.editable-area');
                          if (editableArea) {
                              editableArea.style.setProperty('color', textColor, 'important');
                          }
                      }, 0);
                  }
              }

              const pageContentBack = document.createElement('div');
              pageContentBack.className = 'page-content';
              
              const editableBack = document.createElement('div');
              // Only make editable if user is authenticated and not special pages
              editableBack.contentEditable = String(isAuthenticated && !isBackCover && backPageData.id !== 'placeholder');
              editableBack.className = 'editable-area';
              editableBack.setAttribute('data-page-id', backPageData.id);
              editableBack.innerHTML = backPageData.content || '';
              
              if (!isBackCover && backPageData.id !== 'placeholder') {
                if (isAuthenticated) {
                  editableBack.addEventListener('input', handlePageInput);
                  editableBack.setAttribute('placeholder', `Start writing on page ${backPageData.page_number}...`);
                }
                // Load highlights for this page
                loadHighlightsForPage(backPageData.id, editableBack);
              }
              editableBack.addEventListener('focus', () => { activeEditableArea = editableBack; });

              pageContentBack.appendChild(editableBack);
              
              if (!isBackCover && backPageData.page_number > 0) {
                 const pageNumBack = document.createElement('div');
                 pageNumBack.className = 'page-number-left';
                 pageNumBack.textContent = backPageData.page_number;
                 pageContentBack.appendChild(pageNumBack);
              }

              pageBack.appendChild(pageContentBack);
              sheet.appendChild(pageBack);
          }
          bookContainer.appendChild(sheet);
        }
        updateButtons();
      }

      function handlePageInput(event) {
          const editableArea = event.target;
          const pageId = editableArea.dataset.pageId;

          if (pageId === 'cover' || pageId === 'back-cover' || pageId === 'placeholder' || isNaN(parseInt(pageId))) return;

          clearTimeout(debounceTimeout);
          debounceTimeout = setTimeout(() => {
              const pageIndex = book.pages.findIndex(p => p.id == pageId);
              if (pageIndex > -1) {
                  const content = editableArea.innerHTML;
                  if (book.pages[pageIndex].content !== content) {
                    book.pages[pageIndex].content = content;
                    updatePage(pageId, { content: content });
                  }
              }
          }, DEBOUNCE_DELAY);
      }
      
      function updateButtons() {
        if (!book) return;
        const numSheets = bookContainer.children.length;
        prevBtn.disabled = currentSpread === 0 || isFlipping;
        nextBtn.disabled = currentSpread >= numSheets || isFlipping;

        if (currentSpread === 0) {
            bookContainer.classList.add('closed');
        } else {
            bookContainer.classList.remove('closed');
        }
      }

      function flip(sheetElement, to) {
        isFlipping = true;
        updateButtons();
        
        const numSheets = bookContainer.children.length;
        if (to === 'next') {
            sheetElement.classList.add('flipped');
            sheetElement.style.zIndex = currentSpread + numSheets;
        } else {
            sheetElement.classList.remove('flipped');
            sheetElement.style.zIndex = numSheets - currentSpread + 1;
        }

        setTimeout(() => {
          isFlipping = false;
          updateButtons();
        }, FLIP_DURATION);
      }

      function goToNextSpread() {
        const numSheets = bookContainer.children.length;
        if (currentSpread < numSheets && !isFlipping) {
          const sheetToFlip = bookContainer.children[currentSpread];
          if (sheetToFlip) {
            flip(sheetToFlip, 'next');
            currentSpread++;
          }
        }
      }

      function goToPrevSpread() {
        if (currentSpread > 0 && !isFlipping) {
          currentSpread--;
          const sheetToFlip = bookContainer.children[currentSpread];
          if (sheetToFlip) {
            flip(sheetToFlip, 'prev');
          }
        }
      }
      
      // Keyboard navigation
      document.addEventListener('keydown', (e) => {
        // Only handle arrow keys if not typing in editable area
        if (e.target.getAttribute('contenteditable') === 'true') {
          return; // Don't interfere with typing
        }
        
        if (e.key === 'ArrowLeft') {
          e.preventDefault();
          goToPrevSpread();
        } else if (e.key === 'ArrowRight') {
          e.preventDefault();
          goToNextSpread();
        }
      });

      async function handleAddPage() {
        // Check authentication first
        if (!isAuthenticated) {
            alert("Vui l√≤ng ƒëƒÉng nh·∫≠p ƒë·ªÉ th√™m trang m·ªõi!");
            return;
        }
        
        addPageBtn.disabled = true;
        
        try {
            // SAVE DATA OF CURRENTLY EDITED PAGE BEFORE ADDING NEW PAGES
            // This prevents data loss when renderBook() re-renders
            const currentEditableArea = document.querySelector('.editable-area:focus') || document.querySelector('.editable-area[contenteditable="true"]');
            if (currentEditableArea) {
                // Force save current page content
                const pageId = currentEditableArea.dataset.pageId;
                if (pageId && pageId !== 'cover' && pageId !== 'back-cover' && pageId !== 'placeholder' && !isNaN(parseInt(pageId))) {
                    const pageIndex = book.pages.findIndex(p => p.id == pageId);
                    if (pageIndex > -1) {
                        const content = currentEditableArea.innerHTML;
                        if (book.pages[pageIndex].content !== content) {
                            book.pages[pageIndex].content = content;
                            await updatePage(pageId, { content: content });
                            console.log("Saved current page content before adding new pages");
                        }
                    }
                }
            }
            
            // Since renderBook() now creates real pages instead of placeholders,
            // we need to get the actual last page number from the database
            const lastPageNum = book.pages.length > 0 ? Math.max(...book.pages.map(p => p.page_number)) : 0;
            
            // We always add two pages to maintain the even layout
            const newPage1Data = { page_number: lastPageNum + 1, title: `Page ${lastPageNum + 1}`, content: '' };
            const newPage2Data = { page_number: lastPageNum + 2, title: `Page ${lastPageNum + 2}`, content: '' };
            
            const createdPage1 = await createPage(newPage1Data);
            if (createdPage1) {
                book.pages.push(createdPage1);
                console.log("Page 1 added:", createdPage1);
            }

            const createdPage2 = await createPage(newPage2Data);
            if (createdPage2) {
                book.pages.push(createdPage2);
                console.log("Page 2 added:", createdPage2);
            }
            
            // Sort and re-render immediately for live update
            book.pages.sort((a, b) => a.page_number - b.page_number);
            await renderBook(); // Use await since renderBook is now async
            
            // Auto-flip to the new pages
            setTimeout(() => {
                const numSheets = bookContainer.children.length;
                if (currentSpread < numSheets - 1) {
                    goToNextSpread();
                }
            }, 300);
        } catch (error) {
            console.error("Error adding pages:", error);
            alert("Kh√¥ng th·ªÉ th√™m trang. Vui l√≤ng ƒëƒÉng nh·∫≠p v√† th·ª≠ l·∫°i.");
        } finally {
            addPageBtn.disabled = false;
        }
      }

      function formatDoc(cmd, value = null) {
        if (activeEditableArea) {
            activeEditableArea.focus();
            document.execCommand(cmd, false, value);
            const event = new Event('input', { bubbles: true, cancelable: true });
            activeEditableArea.dispatchEvent(event);
        }
      }
      
      function triggerSave(element) {
        if(element) {
            const event = new Event('input', { bubbles: true, cancelable: true });
            element.dispatchEvent(event);
        }
      }

      // --- MODAL LOGIC ---
      function showInputModal(title, fields, callback) {
        inputModalTitle.textContent = title;
        inputModalContent.innerHTML = '';
        fields.forEach(field => {
            const label = `<label for="modal-input-${field.id}">${field.label}</label>`;
            let input;
            if (field.type === 'color') {
                 input = `<input type="color" id="modal-input-${field.id}" value="${field.value || ''}">`;
            } else {
                 input = `<input type="${field.type || 'text'}" id="modal-input-${field.id}" placeholder="${field.placeholder || ''}" value="${field.value || ''}">`;
            }
            inputModalContent.innerHTML += label + input;
        });
        inputModal.style.display = 'block';
        inputModalOverlay.style.display = 'block';
        inputModalCallback = callback;
      }

      function hideInputModal() {
          inputModal.style.display = 'none';
          inputModalOverlay.style.display = 'none';
          inputModalCallback = null;
      }
      
      // Selection save/restore functions
      function saveSelection(containerEl) {
        const selection = window.getSelection();
        if (selection.rangeCount > 0) {
          const range = selection.getRangeAt(0);
          return {
            startContainer: range.startContainer,
            startOffset: range.startOffset,
            endContainer: range.endContainer,
            endOffset: range.endOffset,
            commonAncestorContainer: range.commonAncestorContainer
          };
        }
        return null;
      }
      
      function restoreSelection(containerEl, savedSel) {
        if (savedSel) {
          const selection = window.getSelection();
          selection.removeAllRanges();
          const range = document.createRange();
          range.setStart(savedSel.startContainer, savedSel.startOffset);
          range.setEnd(savedSel.endContainer, savedSel.endOffset);
          selection.addRange(range);
        }
      }
      
      inputModalSaveBtn.addEventListener('click', () => {
          if (inputModalCallback) {
              const inputs = inputModalContent.querySelectorAll('input');
              const values = {};
              inputs.forEach(input => {
                  values[input.id.replace('modal-input-', '')] = input.value;
              });
              inputModalCallback(values);
          }
          hideInputModal();
      });
      inputModalCancelBtn.addEventListener('click', hideInputModal);

      // --- TOOLBAR EVENT LISTENERS ---
      boldBtn.addEventListener('click', () => formatDoc('bold'));
      italicBtn.addEventListener('click', () => formatDoc('italic'));
      underlineBtn.addEventListener('click', () => formatDoc('underline'));
      imageBtn.addEventListener('click', () => imageUpload.click());

      fontsizeBtn.addEventListener('click', () => {
        if (!activeEditableArea) {
          activeEditableArea = document.querySelector('.editable-area:focus') || document.querySelector('.editable-area[contenteditable="true"]');
        }
        
        // Save current selection before showing modal
        const savedSelection = saveSelection(activeEditableArea);
        
        if (activeEditableArea) {
          activeEditableArea.focus();
        }
        
        showInputModal('Font Size', [{id: 'size', label: 'Enter font size (e.g., 16px):'}], (values) => {
          if (values.size && activeEditableArea) {
            // Restore selection
            restoreSelection(activeEditableArea, savedSelection);
            
            const selection = window.getSelection();
            if (selection.rangeCount > 0 && selection.toString().length > 0) {
              const range = selection.getRangeAt(0);
              const span = document.createElement('span');
              span.style.fontSize = values.size;
              try {
                span.appendChild(range.extractContents());
                range.insertNode(span);
                triggerSave(activeEditableArea);
              } catch(e) { 
                console.error('Font size error:', e); 
              }
            } else {
              // Apply to entire editable area if no selection
              activeEditableArea.style.fontSize = values.size;
              triggerSave(activeEditableArea);
            }
          }
        });
      });
      
      fontcolorBtn.addEventListener('click', () => {
        if (!activeEditableArea) {
          activeEditableArea = document.querySelector('.editable-area:focus') || document.querySelector('.editable-area[contenteditable="true"]');
        }
        
        // Save current selection before showing modal
        const savedSelection = saveSelection(activeEditableArea);
        
        if (activeEditableArea) {
          activeEditableArea.focus();
        }
        
        showInputModal('M√†u ch·ªØ', [{id: 'color', label: 'ƒê·ªïi m√†u ch·ªØ:', type: 'color', value: '#ffffff'}], (values) => {
          if (values.color && activeEditableArea) {
            // Restore selection
            restoreSelection(activeEditableArea, savedSelection);
            
            const selection = window.getSelection();
            if (selection.rangeCount > 0 && selection.toString().length > 0) {
              const range = selection.getRangeAt(0);
              const span = document.createElement('span');
              span.style.color = values.color;
              try {
                span.appendChild(range.extractContents());
                range.insertNode(span);
                triggerSave(activeEditableArea);
              } catch(e) { 
                console.error('Font color error:', e); 
              }
            } else {
              // Apply to entire editable area if no selection
              activeEditableArea.style.color = values.color;
              triggerSave(activeEditableArea);
            }
          }
        });
      });
      
      tableBtn.addEventListener('click', () => {
        if (!activeEditableArea) {
          activeEditableArea = document.querySelector('.editable-area:focus') || document.querySelector('.editable-area[contenteditable="true"]');
        }
        
        // Save current selection before showing modal
        const savedSelection = saveSelection(activeEditableArea);
        
        if (activeEditableArea) {
          activeEditableArea.focus();
        }
        
        showInputModal('T·∫°o b·∫£ng', [
            {id: 'rows', label: 'S·ªë h√†ng:', type: 'number', value: '3'},
            {id: 'cols', label: 'S·ªë c·ªôt:', type: 'number', value: '3'}
        ], (values) => {
          const rows = parseInt(values.rows, 10);
          const cols = parseInt(values.cols, 10);
          if (rows > 0 && cols > 0 && activeEditableArea) {
              // Restore selection
              restoreSelection(activeEditableArea, savedSelection);
              
              let table = '<table border="1"><tbody>';
              for (let i = 0; i < rows; i++) {
                  table += '<tr>';
                  for (let j = 0; j < cols; j++) {
                      table += '<td>&nbsp;</td>';
                  }
                  table += '</tr>';
              }
              table += '</tbody></table>';
              
              const selection = window.getSelection();
              if (selection.rangeCount > 0) {
                const range = selection.getRangeAt(0);
                const div = document.createElement('div');
                div.innerHTML = table + '<p></p>';
                try {
                  range.insertNode(div);
                  triggerSave(activeEditableArea);
                } catch(e) { 
                  console.error('Table insert error:', e); 
                }
              } else {
                // Fallback: insert at end of editable area
                activeEditableArea.innerHTML += '<p></p>' + table + '<p></p>';
                triggerSave(activeEditableArea);
              }
          }
        });
      });

      imageUpload.addEventListener('change', () => {
        const file = imageUpload.files[0];
        if (file && activeEditableArea) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = `<img src="${e.target.result}" style="max-width: 100%;" />`;
                formatDoc('insertHTML', img);
            };
            reader.readAsDataURL(file);
        }
        imageUpload.value = '';
      });


      // --- HIGHLIGHT LOGIC ---
      function showHighlightPopover(range) {
        const rect = range.getBoundingClientRect();
        highlightPopover.style.display = 'flex';
        highlightPopover.style.left = `${rect.left + window.scrollX + rect.width / 2 - highlightPopover.offsetWidth / 2}px`;
        highlightPopover.style.top = `${rect.top + window.scrollY - highlightPopover.offsetHeight - 8}px`;
      }
      
      function hideHighlightPopover() {
        highlightPopover.style.display = 'none';
      }

      function showHighlightModal() {
        // Check if selection is within an existing highlight
        let existingMark = null;
        let existingNote = '';
        let existingColor = 'var(--highlight-yellow)';
        
        if (currentSelection) {
            const ancestor = currentSelection.commonAncestorContainer;
            existingMark = ancestor.nodeType === Node.ELEMENT_NODE ? ancestor.closest('mark') : ancestor.parentElement?.closest('mark');
            
            if (existingMark) {
                // Load existing highlight data
                const noteElement = existingMark.querySelector('.highlight-note');
                if (noteElement) {
                    existingNote = noteElement.textContent;
                }
                existingColor = window.getComputedStyle(existingMark).backgroundColor;
            }
        }
        
        // Show/hide remove button based on whether editing existing highlight
        if (existingMark) {
            highlightModalRemoveBtn.style.display = 'inline-block';
        } else {
            highlightModalRemoveBtn.style.display = 'none';
        }
        
        // Set note input
        noteInput.value = existingNote;
        
        // Set color picker
        const selectedColor = colorPicker.querySelector('.selected');
        if(selectedColor) selectedColor.classList.remove('selected');
        
        // Try to match existing color or default to first
        let colorMatched = false;
        if (existingMark) {
            const colorBoxes = colorPicker.querySelectorAll('.color-box');
            for (const box of colorBoxes) {
                const boxColor = window.getComputedStyle(box).backgroundColor;
                if (boxColor === existingColor) {
                    box.classList.add('selected');
                    colorMatched = true;
                    break;
                }
            }
        }
        
        if (!colorMatched) {
            colorPicker.children[0].classList.add('selected');
        }

        highlightModalOverlay.style.display = 'block';
        highlightModal.style.display = 'block';
      }

      function hideHighlightModal() {
        highlightModalOverlay.style.display = 'none';
        highlightModal.style.display = 'none';
        currentSelection = null;
      }
      
      document.addEventListener('mouseup', (e) => {
          setTimeout(() => {
            // Don't show highlight popover if not authenticated
            if (!isAuthenticated) {
                return;
            }
            
            const selection = window.getSelection();
            if (selection.isCollapsed || isFlipping || highlightModal.style.display === 'block' || inputModal.style.display === 'block') {
                hideHighlightPopover();
                return;
            }
            
            const range = selection.getRangeAt(0);
            let editable = range.commonAncestorContainer.nodeType === Node.ELEMENT_NODE
                ? range.commonAncestorContainer.closest('.editable-area')
                : range.commonAncestorContainer.parentElement.closest('.editable-area');

            if (editable) {
                // Check if we're on a cover page - don't allow highlight on cover
                const coverPage = editable.closest('.is-cover, .is-back-cover');
                if (coverPage) {
                    hideHighlightPopover();
                    return;
                }
                
                currentSelection = range.cloneRange();
                showHighlightPopover(range);
            } else {
                hideHighlightPopover();
            }
          }, 10);
      });
      
      document.addEventListener('mousedown', (e) => {
          if (!highlightPopover.contains(e.target)) {
              hideHighlightPopover();
          }
      });
      
      document.addEventListener('click', (e) => {
        if(e.target.tagName === 'IMG' && e.target.closest('.editable-area')) {
            selectedImage = e.target;
            showInputModal('Image Size', [{id: 'width', label: 'Enter new image width (e.g., 300px or 50%):', value: selectedImage.style.width}], (values) => {
                if(values.width) {
                    selectedImage.style.width = values.width;
                    selectedImage.style.height = 'auto';
                    triggerSave(selectedImage.closest('.editable-area'));
                }
                selectedImage = null;
            });
        }
      });

      popoverHighlightBtn.addEventListener('click', () => {
          if (currentSelection) {
              hideHighlightPopover();
              showHighlightModal();
          }
      });

      popoverRemoveHighlightBtn.addEventListener('click', async () => {
        if(currentSelection) {
            const ancestor = currentSelection.commonAncestorContainer;
            const mark = ancestor.nodeType === Node.ELEMENT_NODE ? ancestor.closest('mark') : ancestor.parentElement.closest('mark');
            if(mark) {
                const highlightId = mark.getAttribute('data-highlight-id');
                const editableArea = mark.closest('.editable-area');
                const pageId = editableArea ? editableArea.dataset.pageId : null;
                
                // Remove from DOM
                const parent = mark.parentNode;
                while (mark.firstChild) {
                    parent.insertBefore(mark.firstChild, mark);
                }
                parent.removeChild(mark);
                parent.normalize(); // Merges adjacent text nodes
                
                // Delete from database if it has an ID
                if (highlightId && highlightId !== 'pending' && pageId) {
                    await deleteHighlight(pageId, highlightId);
                }
                
                triggerSave(parent.closest('.editable-area'));
            }
            hideHighlightPopover();
            window.getSelection().removeAllRanges();
        }
      });

      colorPicker.addEventListener('click', (e) => {
          if(e.target.classList.contains('color-box')) {
              const selectedColor = colorPicker.querySelector('.selected');
              if(selectedColor) selectedColor.classList.remove('selected');
              e.target.classList.add('selected');
          }
      });

      highlightModalCancelBtn.addEventListener('click', hideHighlightModal);

      highlightModalRemoveBtn.addEventListener('click', async () => {
        if (!currentSelection) return;
        
        // Find existing mark
        const ancestor = currentSelection.commonAncestorContainer;
        const existingMark = ancestor.nodeType === Node.ELEMENT_NODE ? ancestor.closest('mark') : ancestor.parentElement?.closest('mark');
        
        if (existingMark) {
            const highlightId = existingMark.getAttribute('data-highlight-id');
            const editableArea = existingMark.closest('.editable-area');
            const pageId = editableArea ? editableArea.dataset.pageId : null;
            
            // Remove from DOM
            const parent = existingMark.parentNode;
            while (existingMark.firstChild) {
                parent.insertBefore(existingMark.firstChild, existingMark);
            }
            parent.removeChild(existingMark);
            parent.normalize(); // Merges adjacent text nodes
            
            // Delete from database if it has an ID
            if (highlightId && highlightId !== 'pending' && pageId) {
                await deleteHighlight(pageId, highlightId);
            }
            
            triggerSave(parent.closest('.editable-area'));
        }
        
        hideHighlightModal();
        window.getSelection().removeAllRanges();
      });

      highlightModalSaveBtn.addEventListener('click', async () => {
        if (!currentSelection) return;

        const noteText = noteInput.value;
        const selectedColorEl = colorPicker.querySelector('.selected');
        const color = selectedColorEl.dataset.color;
        const highlightedText = currentSelection.toString();

        // Check if we're editing an existing highlight
        const ancestor = currentSelection.commonAncestorContainer;
        const existingMark = ancestor.nodeType === Node.ELEMENT_NODE ? ancestor.closest('mark') : ancestor.parentElement?.closest('mark');

        // Get the editable area and page ID
        const editableArea = currentSelection.commonAncestorContainer.nodeType === Node.ELEMENT_NODE
            ? currentSelection.commonAncestorContainer.closest('.editable-area')
            : currentSelection.commonAncestorContainer.parentElement.closest('.editable-area');
        
        if (!editableArea) {
            console.error("Could not find editable area");
            hideHighlightModal();
            return;
        }

        const pageId = editableArea.dataset.pageId;
        if (pageId === 'cover' || pageId === 'back-cover' || pageId === 'placeholder' || isNaN(parseInt(pageId))) {
            console.warn("Cannot highlight on special pages");
            hideHighlightModal();
            return;
        }

        if (existingMark) {
            // Update existing highlight
            existingMark.style.backgroundColor = color;
            
            // Update or add note
            let noteSpan = existingMark.querySelector('.highlight-note');
            if (noteText) {
                if (!noteSpan) {
                    noteSpan = document.createElement('span');
                    noteSpan.className = 'highlight-note';
                    existingMark.insertBefore(noteSpan, existingMark.firstChild);
                }
                noteSpan.textContent = noteText;
            } else if (noteSpan) {
                noteSpan.remove();
            }
            
            // Update in database if it has an ID
            const highlightId = existingMark.getAttribute('data-highlight-id');
            if (highlightId && highlightId !== 'pending') {
                // Note: You may need to add an update endpoint, for now we'll just trigger save
                triggerSave(editableArea);
            }
        } else {
            // Create new highlight
            // Calculate offsets relative to the editable area's text content
            const range = currentSelection.cloneRange();
            const preRange = document.createRange();
            preRange.selectNodeContents(editableArea);
            preRange.setEnd(range.startContainer, range.startOffset);
            const startOffset = preRange.toString().length;
            const endOffset = startOffset + highlightedText.length;

            // Apply visual highlight
            const mark = document.createElement('mark');
            mark.style.backgroundColor = color;
            mark.setAttribute('data-highlight-id', 'pending'); // Will be updated after save
            
            if (noteText) {
                const noteSpan = document.createElement('span');
                noteSpan.className = 'highlight-note';
                noteSpan.textContent = noteText;
                mark.appendChild(noteSpan);
            }

            try {
              mark.appendChild(currentSelection.extractContents());
              currentSelection.insertNode(mark);
            } catch(e) {
                console.error("Could not apply highlight:", e);
                hideHighlightModal();
                return;
            }

            // Save to database
            const highlightData = {
                color: color,
                highlighted_text: highlightedText,
                note: noteText,
                start_offset: startOffset,
                end_offset: endOffset
            };

            const savedHighlight = await saveHighlight(pageId, highlightData);
            if (savedHighlight) {
                mark.setAttribute('data-highlight-id', savedHighlight.id);
                console.log("Highlight saved with ID:", savedHighlight.id);
            }

            triggerSave(mark.closest('.editable-area'));
        }

        hideHighlightModal();
        window.getSelection().removeAllRanges();
      });

      // --- BOOK SETTINGS MODAL ---
      {{if .IsAuthor}}
      const bookSettingsBtn = document.getElementById('book-settings-btn');
      const bookSettingsModal = document.getElementById('book-settings-modal');
      const bookSettingsForm = document.getElementById('book-settings-form');
      const closeBookSettingsBtns = document.querySelectorAll('[data-action="close-book-settings"]');

      if (bookSettingsBtn && bookSettingsModal) {
          bookSettingsBtn.addEventListener('click', () => {
              bookSettingsModal.style.display = 'flex';
          });

          closeBookSettingsBtns.forEach(btn => {
              btn.addEventListener('click', () => {
                  bookSettingsModal.style.display = 'none';
              });
          });

          bookSettingsModal.addEventListener('click', (e) => {
              if (e.target === bookSettingsModal) {
                  bookSettingsModal.style.display = 'none';
              }
          });

          // Handle form submission
          if (bookSettingsForm) {
              bookSettingsForm.addEventListener('submit', async (e) => {
                  e.preventDefault();
                  
                  const formData = new FormData(bookSettingsForm);
                  const data = {
                      title: formData.get('title'),
                      description: formData.get('description'),
                      cover_url: formData.get('cover_url'),
                      cover_color: formData.get('cover_color'),
                      published: formData.get('published') === 'on'
                  };

                  try {
                      const response = await fetch(`/books/${BOOK_ID}/edit`, {
                          method: 'POST',
                          headers: { 'Content-Type': 'application/json' },
                          body: JSON.stringify(data)
                      });

                      const result = await response.json();
                      if (result.success) {
                          // Update the book data and re-render
                          book.title = data.title;
                          book.description = data.description;
                          book.cover_url = data.cover_url;
                          book.cover_color = data.cover_color;
                          book.published = data.published;
                          
                          bookSettingsModal.style.display = 'none';
                          await renderBook(); // Re-render to show updated cover
                          alert('C·∫≠p nh·∫≠t s√°ch th√†nh c√¥ng!');
                      } else {
                          alert(result.error || 'L·ªói c·∫≠p nh·∫≠t s√°ch');
                      }
                  } catch (error) {
                      console.error('Error updating book:', error);
                      alert('L·ªói k·∫øt n·ªëi khi c·∫≠p nh·∫≠t s√°ch');
                  }
              });

              // Handle cancel
              document.querySelector('[data-action="cancel-book-settings"]')?.addEventListener('click', () => {
                  bookSettingsModal.style.display = 'none';
              });

              // Auto text color based on background color
              const colorInput = bookSettingsForm.querySelector('input[type="color"]');
              const colorTextInput = bookSettingsForm.querySelector('input[type="text"][pattern]');
              
              function getTextColorForBackground(hexColor) {
                  // Convert hex to RGB
                  const r = parseInt(hexColor.substr(1, 2), 16);
                  const g = parseInt(hexColor.substr(3, 2), 16);
                  const b = parseInt(hexColor.substr(5, 2), 16);
                  
                  // Calculate relative luminance (ITU-R BT.709)
                  const luminance = (0.2126 * r + 0.7152 * g + 0.0722 * b) / 255;
                  
                  // Return black for light backgrounds, white for dark backgrounds
                  return luminance > 0.5 ? 'black' : 'white';
              }
              
              function updateColorPreview(color) {
                  const textColor = getTextColorForBackground(color);
                  
                  // Update color picker container background and text
                  const colorPickerContainer = bookSettingsForm.querySelector('.color-picker-container');
                  if (colorPickerContainer) {
                      colorPickerContainer.style.backgroundColor = color;
                      colorPickerContainer.style.padding = '0.5rem';
                      colorPickerContainer.style.borderRadius = '8px';
                      
                      // Update text input color
                      if (colorTextInput) {
                          colorTextInput.style.color = textColor;
                      }
                  }
              }
              
              if (colorInput && colorTextInput) {
                  colorInput.addEventListener('input', (e) => {
                      const color = e.target.value;
                      colorTextInput.value = color;
                      updateColorPreview(color);
                  });
                  
                  colorTextInput.addEventListener('input', (e) => {
                      const color = e.target.value.trim();
                      if (/^#[0-9A-Fa-f]{6}$/.test(color)) {
                          colorInput.value = color;
                          updateColorPreview(color);
                      }
                  });
                  
                  // Set initial preview
                  updateColorPreview(colorInput.value);
              }
          }
      }
      {{end}}

      // --- INITIALIZATION ---
      fetchBook();
      prevBtn.addEventListener('click', goToPrevSpread);
      nextBtn.addEventListener('click', goToNextSpread);
      addPageBtn.addEventListener('click', handleAddPage);
    });
  </script>
</body>
</html>