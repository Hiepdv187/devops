<article class="post-detail">
    <header class="hero hero-basic">
        <div class="hero-header">
            <div class="hero-text">
                <h1>{{.Post.Title}}</h1>
                <p class="meta">B·ªüi {{.Post.AuthorName}} ¬∑ {{.Post.CreatedLabel}}</p>
            </div>
        </div>
        {{if .Post.Summary}}
        <p class="summary">{{.Post.Summary}}</p>
        {{end}}
        
    </header>
    {{if .IsAuthor}}
    <section class="card post-editor" id="post-editor" hidden>
        <div class="composer-grid">
            <form method="post" action="/posts/{{.Post.ID}}/edit" class="stack" id="post-edit-form">
                <label>T·ª±a ƒë·ªÅ
                    <input type="text" name="title" value="{{.Post.Title}}" placeholder="Ti√™u ƒë·ªÅ b√†i vi·∫øt" required minlength="3" data-preview="title">
                </label>
                <label>T√≥m t·∫Øt ng·∫Øn
                    <input type="text" name="summary" value="{{.Post.Summary}}" placeholder="T√≥m t·∫Øt ng·∫Øn g·ªçn" data-preview="summary">
                </label>
                <label>·∫¢nh b√¨a (URL)
                    <input type="url" name="cover_url" value="{{.Post.CoverURL}}" placeholder="https://example.com/cover.jpg" data-preview="cover">
                </label>
                <label>Tags (ph√¢n lo·∫°i)
                    <input type="text" name="tags" value="{{.Post.Tags}}" placeholder="docker, kubernetes, ci-cd" data-preview="tags">
                    <small style="color: #94a3b8; font-size: 0.85rem;">Nh·∫≠p c√°c tags c√°ch nhau b·∫±ng d·∫•u ph·∫©y</small>
                </label>
                <label>N·ªôi dung b√†i vi·∫øt
                    <div id="edit-editor-container" style="min-height: 300px; background: rgba(15, 23, 42, 0.65); border: 1px solid rgba(148, 163, 184, 0.3); border-radius: 8px;"></div>
                    <textarea name="content" id="edit-content-textarea" hidden required minlength="10">{{.Post.Content}}</textarea>
                </label>
                <div class="form-actions">
                    <button type="submit" class="btn primary">L∆∞u thay ƒë·ªïi</button>
                    <button type="button" class="btn ghost" data-action="close-editor">H·ªßy</button>
                </div>
            </form>
            <aside class="preview" id="post-edit-preview">
                <h3 class="preview-heading">Xem tr∆∞·ªõc b√†i vi·∫øt</h3>
                <figure class="preview-cover" data-visible="{{if .Post.CoverURL}}true{{else}}false{{end}}">
                    <img src="{{.Post.CoverURL}}" alt="·∫¢nh b√¨a xem tr∆∞·ªõc" loading="lazy">
                </figure>
                <h3 class="preview-title">{{.Post.Title}}</h3>
                <p class="preview-meta">B·ªüi {{.Post.AuthorName}} ¬∑ {{.Post.CreatedLabel}}</p>
                <p class="preview-summary">{{if .Post.Summary}}{{.Post.Summary}}{{else}}T√≥m t·∫Øt s·∫Ω gi√∫p ng∆∞·ªùi ƒë·ªçc hi·ªÉu nhanh n·ªôi dung ch√≠nh c·ªßa b√†i vi·∫øt.{{end}}</p>
                <div class="preview-content" id="post-edit-preview-content"></div>
            </aside>
        </div>
    </section>
    {{end}}
    
    <div class="post-meta-actions">
        {{if .Post.Tags}}
        <div class="post-tags">
            {{range .PostTags}}
            <a href="/posts?tag={{.}}" class="tag-badge">{{.}}</a>
            {{end}}
        </div>
        {{end}}
        {{if .IsAuthor}}
        <div class="post-author-actions">
            <button type="button" class="btn ghost" data-action="toggle-editor">Ch·ªânh s·ª≠a b√†i vi·∫øt</button>
        </div>
        {{end}}
    </div>
    
    <section class="card post-body" id="post-body" data-post-id="{{.Post.ID}}" data-auth="{{if .IsAuthenticated}}true{{else}}false{{end}}">
        {{.Post.Content | safeHTML}}
    </section>
    <div class="post-image-lightbox" id="post-image-lightbox" aria-hidden="true">
        <figure class="lightbox-content">
            <button type="button" class="lightbox-close" aria-label="ƒê√≥ng" data-action="close-lightbox">√ó</button>
            <img src="" alt="·∫¢nh ph√≥ng to" loading="lazy">
            <figcaption hidden></figcaption>
        </figure>
    </div>
</article>
{{if .IsAuthor}}
<link href="https://cdn.quilljs.com/1.3.7/quill.snow.css" rel="stylesheet">
<link href="https://cdn.quilljs.com/1.3.7/quill.bubble.css" rel="stylesheet">
<script src="https://cdn.quilljs.com/1.3.7/quill.min.js"></script>
<style>
.ql-snow .ql-picker.ql-expanded .ql-picker-label {
    border-color: rgba(148, 163, 184, 0.5);
}
.ql-snow .ql-picker.ql-expanded .ql-picker-options {
    display: block;
    background: rgba(15, 23, 42, 0.98);
    border: 1px solid rgba(148, 163, 184, 0.3);
    border-radius: 8px;
    margin-top: 2px;
}
.ql-snow .ql-color-picker .ql-picker-item {
    border: 1px solid rgba(148, 163, 184, 0.2);
}
.ql-snow .ql-picker-options {
    z-index: 100;
}
.ql-snow .ql-picker-label:active,
.ql-snow .ql-picker-label:focus {
    outline: none;
}
.ql-toolbar.ql-snow .ql-picker.ql-expanded .ql-picker-options {
    display: block !important;
    opacity: 1 !important;
    visibility: visible !important;
}
</style>
{{end}}
<script>
window.LINE_COMMENTS = {{.LineComments | json}};
window.LINE_ANNOTATIONS = {{.LineAnnotations | json}};
window.IS_AUTHOR = {{.IsAuthor}};
</script>
<section class="comments" id="comments">
    <header class="section-header">
        <h2>B√¨nh lu·∫≠n</h2>
        <p>Th·∫£o lu·∫≠n v√† ƒë√≥ng g√≥p √Ω ki·∫øn c·ªßa b·∫°n ƒë·ªÉ c√πng c·∫£i thi·ªán quy tr√¨nh DevOps.</p>
    </header>
    {{if .GeneralComments}}
    <div class="stack comment-list">
        {{range .GeneralComments}}
        <article class="card comment-card">
            <p style="white-space: pre-wrap; word-wrap: break-word;">{{.Content}}</p>
            <p class="meta">B·ªüi {{.AuthorName}} ¬∑ {{.CreatedAt}}</p>
        </article>
        {{end}}
    </div>
    {{else}}
    <p class="empty">Ch∆∞a c√≥ b√¨nh lu·∫≠n chung. H√£y m·ªü ƒë·∫ßu cu·ªôc tr√≤ chuy·ªán!</p>
    {{end}}
</section>
<section class="comment-form card" id="add-comment">
    <h3>ƒê√≥ng g√≥p b√¨nh lu·∫≠n</h3>
    {{if .IsAuthenticated}}
    <form method="post" action="/posts/{{.Post.ID}}/comments" class="stack">
        <textarea name="content" rows="4" placeholder="Chia s·∫ª kinh nghi·ªám, b√†i h·ªçc, ho·∫∑c c√¢u h·ªèi c·ªßa b·∫°n" required minlength="3"></textarea>
        <button type="submit" class="btn primary">G·ª≠i b√¨nh lu·∫≠n</button>
    </form>
    {{else}}
    <p>B·∫°n c·∫ßn <a href="/auth/login?next=/posts/{{.Post.ID}}#add-comment">ƒëƒÉng nh·∫≠p</a> ƒë·ªÉ b√¨nh lu·∫≠n. Ch∆∞a c√≥ t√†i kho·∫£n? <a href="/auth/register?next=/posts/{{.Post.ID}}#add-comment">ƒêƒÉng k√Ω ngay</a>.</p>
    {{end}}
</section>
<script>
document.addEventListener('DOMContentLoaded', () => {
    const postBody = document.getElementById('post-body');
    if (!postBody) return;

    const postId = postBody.dataset.postId;
    const isAuth = postBody.dataset.auth === 'true';
    const lineComments = window.LINE_COMMENTS || {};
    const lineAnnotations = window.LINE_ANNOTATIONS || {};
    const isAuthor = window.IS_AUTHOR || false;
    
    const lightbox = document.getElementById('post-image-lightbox');
    const lightboxImg = lightbox?.querySelector('img');
    const lightboxCaption = lightbox?.querySelector('figcaption');
    const lightboxCloseBtn = lightbox?.querySelector('[data-action="close-lightbox"]');

    const openLightbox = (img) => {
        if (!lightbox || !lightboxImg) return;
        const fullSrc = img.getAttribute('data-full-src') || img.currentSrc || img.src;
        lightboxImg.src = fullSrc;
        lightboxImg.alt = img.alt || '·∫¢nh ph√≥ng to';
        if (lightboxCaption) {
            const caption = img.getAttribute('alt') || img.getAttribute('title') || '';
            if (caption) {
                lightboxCaption.textContent = caption;
                lightboxCaption.hidden = false;
            } else {
                lightboxCaption.hidden = true;
                lightboxCaption.textContent = '';
            }
        }
        lightbox.removeAttribute('data-zoomed');
        lightbox.setAttribute('data-active', 'true');
        lightbox.setAttribute('aria-hidden', 'false');
        document.body.classList.add('lightbox-open');
    };

    const closeLightbox = () => {
        if (!lightbox || !lightboxImg) return;
        lightbox.removeAttribute('data-active');
        lightbox.removeAttribute('data-zoomed');
        lightbox.setAttribute('aria-hidden', 'true');
        document.body.classList.remove('lightbox-open');
        setTimeout(() => {
            lightboxImg.src = '';
        }, 200);
    };

    const toggleZoom = () => {
        if (!lightbox) return;
        const isZoomed = lightbox.getAttribute('data-zoomed') === 'true';
        if (isZoomed) {
            lightbox.removeAttribute('data-zoomed');
        } else {
            lightbox.setAttribute('data-zoomed', 'true');
        }
    };

    if (lightbox) {
        lightbox.addEventListener('click', (event) => {
            if (event.target === lightbox) {
                closeLightbox();
            }
        });
    }

    lightboxCloseBtn?.addEventListener('click', closeLightbox);
    lightboxImg?.addEventListener('click', toggleZoom);

    document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape' && lightbox?.getAttribute('data-active') === 'true') {
            closeLightbox();
        }
    });

    const attachLightbox = (root) => {
        if (!root) return;
        root.querySelectorAll('img').forEach((img) => {
            if (img.dataset.lightboxBound === 'true') return;
            img.dataset.lightboxBound = 'true';
            img.addEventListener('click', () => openLightbox(img));
        });
    };

    attachLightbox(postBody);

    // Global reference to Quill editor for live updates
    let editQuill = null;

    if (isAuthor) {
        const toggleEditorBtn = document.querySelector('[data-action="toggle-editor"]');
        const editorSection = document.getElementById('post-editor');
        const postBodySection = document.getElementById('post-body');
        const closeEditorBtn = document.querySelector('[data-action="close-editor"]');
        const editForm = document.getElementById('post-edit-form');
        const preview = document.getElementById('post-edit-preview');

        if (toggleEditorBtn && editorSection && postBodySection && editForm && preview) {
            const previewElements = {
                title: preview.querySelector('.preview-title'),
                summary: preview.querySelector('.preview-summary'),
                content: preview.querySelector('.preview-content'),
                coverWrapper: preview.querySelector('.preview-cover'),
                coverImg: preview.querySelector('.preview-cover img'),
            };

            const textarea = editForm.querySelector('#edit-content-textarea');
            const defaultSummary = 'T√≥m t·∫Øt s·∫Ω gi√∫p ng∆∞·ªùi ƒë·ªçc hi·ªÉu nhanh n·ªôi dung ch√≠nh c·ªßa b√†i vi·∫øt.';
            const defaultContent = '<p>N·ªôi dung b√†i vi·∫øt hi·ªÉn th·ªã theo t·ª´ng ƒëo·∫°n...</p>';

            // Initialize Quill editor for edit mode
            if (window.Quill && document.getElementById('edit-editor-container')) {
                editQuill = new Quill('#edit-editor-container', {
                    theme: 'snow',
                    placeholder: 'Ch·ªânh s·ª≠a n·ªôi dung b√†i vi·∫øt...',
                    modules: {
                        toolbar: [
                            [{ 'header': [1, 2, 3, false] }],
                            ['bold', 'italic', 'underline', 'strike'],
                            [{ 'color': [] }, { 'background': [] }],
                            [{ 'list': 'ordered'}, { 'list': 'bullet' }],
                            [{ 'indent': '-1'}, { 'indent': '+1' }],
                            ['link', 'image'],
                            ['clean']
                        ],
                        keyboard: {
                            bindings: {
                                linebreak: {
                                    key: 13,
                                    shiftKey: true,
                                    handler: function(range) {
                                        this.quill.insertText(range.index, '\n', 'user');
                                        this.quill.setSelection(range.index + 1);
                                        return false;
                                    }
                                }
                            }
                        },
                        clipboard: {
                            matchVisual: false
                        }
                    }
                });

                // Create custom bubble toolbar for text selection
                const bubbleToolbar = document.createElement('div');
                bubbleToolbar.className = 'custom-bubble-toolbar';
                bubbleToolbar.style.cssText = 'position: absolute; display: none; z-index: 1000; background: rgba(15, 23, 42, 0.98); border: 1px solid rgba(148, 163, 184, 0.3); border-radius: 8px; padding: 4px; box-shadow: 0 4px 12px rgba(0,0,0,0.3);';
                bubbleToolbar.innerHTML = `
                    <select class="ql-size" title="Font Size" style="width: 70px; height: 28px; border: 1px solid rgba(148, 163, 184, 0.3); background: rgba(30, 41, 59, 0.8); color: #94a3b8; border-radius: 4px; cursor: pointer; font-size: 0.85rem;">
                        <option value="small">Nh·ªè</option>
                        <option selected>B√¨nh th∆∞·ªùng</option>
                        <option value="large">L·ªõn</option>
                        <option value="huge">R·∫•t l·ªõn</option>
                    </select>
                    <button type="button" class="ql-bold" title="Bold" style="width: 28px; height: 28px; border: none; background: transparent; color: #94a3b8; cursor: pointer; border-radius: 4px;"><b>B</b></button>
                    <button type="button" class="ql-italic" title="Italic" style="width: 28px; height: 28px; border: none; background: transparent; color: #94a3b8; cursor: pointer; border-radius: 4px;"><i>I</i></button>
                    <button type="button" class="ql-underline" title="Underline" style="width: 28px; height: 28px; border: none; background: transparent; color: #94a3b8; cursor: pointer; border-radius: 4px;"><u>U</u></button>
                    <button type="button" class="ql-strike" title="Strike" style="width: 28px; height: 28px; border: none; background: transparent; color: #94a3b8; cursor: pointer; border-radius: 4px;"><s>S</s></button>
                    <button type="button" class="ql-link" title="Link" style="width: 28px; height: 28px; border: none; background: transparent; color: #94a3b8; cursor: pointer; border-radius: 4px;">üîó</button>
                    <select class="ql-color" title="Text Color" style="width: 60px; height: 28px; border: 1px solid rgba(148, 163, 184, 0.3); background: rgba(30, 41, 59, 0.8); color: #94a3b8; border-radius: 4px; cursor: pointer;">
                        <option value="#e2e8f0" selected>Default</option>
                        <option value="#38bdf8">Blue</option>
                        <option value="#22c55e">Green</option>
                        <option value="#ef4444">Red</option>
                        <option value="#f59e0b">Orange</option>
                    </select>
                `;
                document.body.appendChild(bubbleToolbar);

                // Handle bubble toolbar button clicks
                bubbleToolbar.querySelectorAll('button').forEach(btn => {
                    btn.addEventListener('mousedown', (e) => {
                        e.preventDefault();
                        const format = btn.className.replace('ql-', '');
                        const currentFormat = editQuill.getFormat();
                        if (format === 'link') {
                            const url = prompt('Enter URL:');
                            if (url) {
                                editQuill.format('link', url);
                            }
                        } else {
                            editQuill.format(format, !currentFormat[format]);
                        }
                    });
                    btn.addEventListener('mouseenter', () => {
                        btn.style.background = 'rgba(56, 189, 248, 0.2)';
                    });
                    btn.addEventListener('mouseleave', () => {
                        btn.style.background = 'transparent';
                    });
                });

                // Handle font size select
                const sizeSelect = bubbleToolbar.querySelector('.ql-size');
                sizeSelect.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                });
                sizeSelect.addEventListener('change', (e) => {
                    e.preventDefault();
                    const selection = editQuill.getSelection();
                    if (selection && selection.length > 0) {
                        editQuill.format('size', e.target.value || false);
                    }
                });

                // Handle color select
                bubbleToolbar.querySelector('.ql-color').addEventListener('change', (e) => {
                    editQuill.format('color', e.target.value);
                });

                // Show/hide bubble toolbar on text selection
                editQuill.on('selection-change', (range) => {
                    if (range && range.length > 0) {
                        const bounds = editQuill.getBounds(range.index, range.length);
                        const editorRect = document.getElementById('edit-editor-container').getBoundingClientRect();
                        
                        bubbleToolbar.style.display = 'flex';
                        bubbleToolbar.style.gap = '2px';
                        bubbleToolbar.style.left = (editorRect.left + bounds.left + (bounds.width / 2) - (bubbleToolbar.offsetWidth / 2)) + 'px';
                        bubbleToolbar.style.top = (editorRect.top + bounds.top - bubbleToolbar.offsetHeight - 8 + window.scrollY) + 'px';
                    } else {
                        bubbleToolbar.style.display = 'none';
                    }
                });

                // Hide bubble toolbar when clicking outside
                document.addEventListener('click', (e) => {
                    if (!bubbleToolbar.contains(e.target) && !document.getElementById('edit-editor-container').contains(e.target)) {
                        bubbleToolbar.style.display = 'none';
                    }
                });

                // Prevent scroll to top on paste
                const editEditorContainer = document.getElementById('edit-editor-container');
                editEditorContainer.addEventListener('paste', function(e) {
                    const scrollPos = window.scrollY;
                    setTimeout(() => {
                        window.scrollTo(0, scrollPos);
                    }, 0);
                });

                // Load existing content - use clipboard to preserve formatting including <br>
                if (textarea && textarea.value) {
                    const delta = editQuill.clipboard.convert(textarea.value);
                    editQuill.setContents(delta, 'silent');
                }

                // Fix picker dropdowns by stopping Quill's default toggle behavior
                setTimeout(() => {
                    const toolbar = document.querySelector('#edit-editor-container')?.previousElementSibling;
                    if (!toolbar) return;
                    
                    const pickers = toolbar.querySelectorAll('.ql-picker');
                    pickers.forEach(picker => {
                        const label = picker.querySelector('.ql-picker-label');
                        if (!label) return;
                        
                        // Stop all events on the label to prevent Quill's handler
                        label.addEventListener('click', function(e) {
                            e.stopImmediatePropagation();
                            
                            // Manually toggle
                            const isExpanded = picker.classList.contains('ql-expanded');
                            
                            // Close all pickers first
                            pickers.forEach(p => p.classList.remove('ql-expanded'));
                            
                            // Open this one if it wasn't open
                            if (!isExpanded) {
                                picker.classList.add('ql-expanded');
                            }
                        }, true);
                        
                        // Prevent mousedown from bubbling
                        label.addEventListener('mousedown', function(e) {
                            e.preventDefault();
                            e.stopImmediatePropagation();
                        }, true);
                    });
                    
                    // Close when clicking outside
                    document.addEventListener('click', function(e) {
                        if (!e.target.closest('.ql-picker')) {
                            pickers.forEach(p => p.classList.remove('ql-expanded'));
                        }
                    });
                }, 300);

                // Sync Quill to textarea and preview
                editQuill.on('text-change', function() {
                    let html = editQuill.root.innerHTML;
                    // Replace text nodes containing \n with <br> tags
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = html;
                    
                    // Walk through all text nodes and replace \n with <br>
                    const walker = document.createTreeWalker(tempDiv, NodeFilter.SHOW_TEXT, null, false);
                    const nodesToReplace = [];
                    while (walker.nextNode()) {
                        const node = walker.currentNode;
                        if (node.nodeValue && node.nodeValue.includes('\n')) {
                            nodesToReplace.push(node);
                        }
                    }
                    
                    nodesToReplace.forEach(node => {
                        const parts = node.nodeValue.split('\n');
                        const fragment = document.createDocumentFragment();
                        parts.forEach((part, i) => {
                            fragment.appendChild(document.createTextNode(part));
                            if (i < parts.length - 1) {
                                fragment.appendChild(document.createElement('br'));
                            }
                        });
                        node.parentNode.replaceChild(fragment, node);
                    });
                    
                    html = tempDiv.innerHTML;
                    textarea.value = html;
                    previewElements.content.innerHTML = html || defaultContent;
                    attachLightbox(previewElements.content);
                });

                // Image upload handler
                editQuill.getModule('toolbar').addHandler('image', function() {
                    const input = document.createElement('input');
                    input.setAttribute('type', 'file');
                    input.setAttribute('accept', 'image/*');
                    input.click();

                    input.onchange = async function() {
                        const file = input.files[0];
                        if (!file) return;

                        const formData = new FormData();
                        formData.append('image', file);

                        try {
                            const response = await fetch('/upload/image', {
                                method: 'POST',
                                body: formData
                            });

                            if (!response.ok) {
                                throw new Error('Upload th·∫•t b·∫°i');
                            }

                            const data = await response.json();
                            const range = editQuill.getSelection(true);
                            editQuill.insertEmbed(range.index, 'image', data.url);
                            editQuill.setSelection(range.index + 1);
                        } catch (error) {
                            alert('L·ªói upload ·∫£nh: ' + error.message);
                        }
                    };
                });
            }

            const updatePreview = (target, value) => {
                switch (target) {
                    case 'title':
                        previewElements.title.textContent = value || 'Ti√™u ƒë·ªÅ b√†i vi·∫øt s·∫Ω hi·ªÉn th·ªã t·∫°i ƒë√¢y';
                        break;
                    case 'summary':
                        previewElements.summary.textContent = value || defaultSummary;
                        break;
                    case 'content': {
                        // Content preview is now handled by Quill editor
                        break;
                    }
                    case 'cover':
                        if (!previewElements.coverWrapper || !previewElements.coverImg) return;
                        if (value) {
                            previewElements.coverImg.src = value;
                            previewElements.coverWrapper.setAttribute('data-visible', 'true');
                        } else {
                            previewElements.coverImg.src = '';
                            previewElements.coverWrapper.setAttribute('data-visible', 'false');
                        }
                        break;
                    default:
                        break;
                }
            };

            const syncPreviewFromForm = () => {
                editForm.querySelectorAll('[data-preview]').forEach((input) => {
                    const target = input.getAttribute('data-preview');
                    updatePreview(target, input.value.trim());
                });
            };

            const openEditor = () => {
                editorSection.hidden = false;
                postBodySection.hidden = true;
                if (toggleEditorBtn) toggleEditorBtn.disabled = true;
                syncPreviewFromForm();
                if (editQuill) {
                    editQuill.focus();
                }
            };

            const closeEditor = () => {
                editorSection.hidden = true;
                postBodySection.hidden = false;
                if (toggleEditorBtn) toggleEditorBtn.disabled = false;
            };

            editForm.querySelectorAll('[data-preview]').forEach((input) => {
                const target = input.getAttribute('data-preview');
                if (!target) return;
                input.addEventListener('input', () => {
                    updatePreview(target, input.value.trim());
                });
            });

            // Old textarea and upload zone handlers removed - now handled by Quill

            toggleEditorBtn?.addEventListener('click', () => {
                openEditor();
            });

            closeEditorBtn?.addEventListener('click', () => {
                closeEditor();
            });

            // Initialize preview with current values
            syncPreviewFromForm();
            if (editQuill && textarea?.value) {
                previewElements.content.innerHTML = textarea.value;
            }
        }
    }

    let lineNumber = 0;
    const blocks = [];
    const annotationBlocks = [];

    const extractInlineAnnotationFromContent = (wrapper) => {
        const contentHolder = wrapper.querySelector('.inline-line-content');
        if (!contentHolder) return '';

        const walker = document.createTreeWalker(contentHolder, NodeFilter.SHOW_TEXT, null);
        const textNodes = [];
        while (walker.nextNode()) {
            textNodes.push(walker.currentNode);
        }

        for (let i = textNodes.length - 1; i >= 0; i--) {
            const node = textNodes[i];
            if (!node.textContent) continue;
            // Ch·ªâ match khi c√≥ d·∫•u c√°ch sau # (# + space)
            const match = node.textContent.match(/[\s\u00a0]*#\s+([^#]+)$/);
            if (match) {
                const annotationText = match[1].trim();
                node.textContent = node.textContent.slice(0, node.textContent.length - match[0].length).replace(/[\s\u00a0]+$/, '');
                if (node.textContent.length === 0) {
                    const parent = node.parentNode;
                    parent.removeChild(node);
                    if (parent.childNodes.length === 0 && parent !== contentHolder) {
                        parent.remove();
                    }
                }
                return annotationText;
            }
        }

        // Handle case where entire line starts with '# ' (with space)
        if (textNodes.length === 1) {
            const text = textNodes[0].textContent.trim();
            const leadingMatch = text.match(/^#\s+([^#]+)$/);
            if (leadingMatch) {
                textNodes[0].textContent = '';
                return leadingMatch[1].trim();
            }
        }

        return '';
    };

    const ensureControlBox = (wrapper) => {
        let box = wrapper.querySelector('.inline-actions-box');
        if (!box) {
            box = document.createElement('span');
            box.className = 'inline-actions-box';
            
            // Insert right after text content
            const contentHolder = wrapper.querySelector('.inline-line-content');
            if (contentHolder) {
                // Append to content holder so it appears inline after text
                contentHolder.appendChild(box);
            } else {
                // Fallback: find the text element and insert after it
                const textEl = wrapper.querySelector('p, h1, h2, h3, h4, h5, h6, span');
                if (textEl && textEl.parentNode === wrapper) {
                    textEl.appendChild(box);
                } else {
                    wrapper.appendChild(box);
                }
            }
        }
        return box;
    };

    const panelPortalRoot = document.createElement('div');
    panelPortalRoot.className = 'inline-portal-root';
    postBody.appendChild(panelPortalRoot);

    const ensurePanelContainer = (wrapper) => {
        let container = panelPortalRoot.querySelector(`.inline-panel-container[data-line="${wrapper.dataset.line}"]`);
        if (!container) {
            container = document.createElement('div');
            container.className = 'inline-panel-container';
            container.dataset.line = wrapper.dataset.line;
            panelPortalRoot.appendChild(container);
        }
        return container;
    };

    const processedElements = [];
    
    // Also include div elements from Quill editor
    postBody.querySelectorAll('p, pre, blockquote, h1, h2, h3, h4, h5, h6, li, div.ql-editor > *').forEach(el => {
        if (el.querySelector('br')) {
            const parts = [];
            let currentPart = document.createElement('span');
            
            Array.from(el.childNodes).forEach(node => {
                if (node.nodeName === 'BR') {
                    if (currentPart.textContent.trim()) {
                        parts.push(currentPart);
                    }
                    currentPart = document.createElement('span');
                } else {
                    currentPart.appendChild(node.cloneNode(true));
                }
            });
            
            if (currentPart.textContent.trim()) {
                parts.push(currentPart);
            }
            
            el.innerHTML = '';
            parts.forEach((part, idx) => {
                if (idx > 0) el.appendChild(document.createElement('br'));
                el.appendChild(part);
                processedElements.push({ element: part, parent: el });
            });
        } else {
            processedElements.push({ element: el, parent: null });
        }
    });
    
    processedElements.forEach(({ element: el }) => {
        if (el.dataset.lineProcessed === 'true') return;

        const text = el.textContent.trim();
        const hasMedia = !!el.querySelector('img, figure, video, iframe');
        const tagName = el.tagName ? el.tagName.toLowerCase() : '';
        const isListItem = tagName === 'li';

        if (text.length === 0 && !hasMedia) return;

        lineNumber++;
        const currentLine = lineNumber;

        if (hasMedia && !isListItem) {
            el.dataset.line = currentLine;
            el.dataset.lineProcessed = 'true';
            el.classList.add('image-line');
            return;
        }

        let wrapper;

        if (isListItem) {
            el.dataset.line = currentLine;
            el.dataset.lineProcessed = 'true';
            el.classList.add('inline-list-item');

            if (el.querySelector(':scope > .inline-line')) {
                wrapper = el.querySelector(':scope > .inline-line');
            } else {
                wrapper = document.createElement('div');
                wrapper.className = 'inline-line';
                wrapper.dataset.line = currentLine;

                const contentHolder = document.createElement('span');
                contentHolder.className = 'inline-line-content';

                while (el.firstChild) {
                    contentHolder.appendChild(el.firstChild);
                }

                wrapper.appendChild(contentHolder);
                el.appendChild(wrapper);
            }
        } else {
            wrapper = document.createElement('span');
            wrapper.className = 'inline-line';
            wrapper.dataset.line = currentLine;
            wrapper.style.display = 'block';

            const contentHolder = document.createElement('span');
            contentHolder.className = 'inline-line-content';

            el.dataset.lineProcessed = 'true';
            el.parentNode.insertBefore(wrapper, el);
            contentHolder.appendChild(el);
            wrapper.appendChild(contentHolder);
        }

        const comments = lineComments[currentLine] || [];
        
        // Extract and remove inline annotation from content
        const inlineAnnotation = extractInlineAnnotationFromContent(wrapper);
        
        // Use stored annotation from backend, or fallback to inline annotation
        const annotation = lineAnnotations[currentLine] || inlineAnnotation || '';
        
        // Get clean text after removing #annotation
        const cleanText = wrapper.textContent.trim();
        
        const controlBox = ensureControlBox(wrapper);
        
        // Debug: ensure box is created
        if (!controlBox) {
            console.error('Failed to create control box for line', currentLine);
            return;
        }

        // Add annotation display if exists
        if (annotation) {
            const annotationSpan = document.createElement('span');
            annotationSpan.className = 'line-annotation';
            annotationSpan.textContent = `# ${annotation}`;
            annotationSpan.title = annotation;
            // Insert into wrapper (not before controlBox which is in content holder)
            wrapper.appendChild(annotationSpan);
        }

        if (isAuthor) {
            const annotateBtn = document.createElement('button');
            annotateBtn.type = 'button';
            annotateBtn.className = 'inline-btn annotate-btn';
            annotateBtn.innerHTML = `üìù`;
            annotateBtn.title = 'Ch√∫ th√≠ch';
            annotateBtn.dataset.line = currentLine;
            controlBox.appendChild(annotateBtn);

            const lineText = cleanText.length > 50 ? cleanText.substring(0, 50) + '...' : cleanText;
            const annotationPanel = document.createElement('div');
            annotationPanel.className = 'inline-panel annotation-panel';
            annotationPanel.hidden = true;
            annotationPanel.dataset.line = currentLine;
            annotationPanel.innerHTML = `
                <div class="inline-panel-header">
                    <span title="${cleanText}">${lineText}</span>
                    <button type="button" class="inline-close">√ó</button>
                </div>
                <form class="annotation-form" data-line="${currentLine}">
                    <textarea placeholder="Nh·∫≠p ch√∫ th√≠ch cho d√≤ng n√†y" minlength="1"></textarea>
                    <div class="annotation-actions">
                        <button type="submit" class="btn primary small">L∆∞u</button>
                        <button type="button" class="btn ghost small annotation-cancel">H·ªßy</button>
                    </div>
                    <p class="inline-error" hidden></p>
                </form>
            `;
            const annotationTextarea = annotationPanel.querySelector('textarea');
            annotationTextarea.value = annotation;
            ensurePanelContainer(wrapper).appendChild(annotationPanel);
            annotationBlocks.push({
                wrapper,
                button: annotateBtn,
                panel: annotationPanel,
                textarea: annotationTextarea,
                lineNumber: currentLine
            });
        }

        if (true) {
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'inline-btn';
            btn.innerHTML = `üí¨${comments.length > 0 ? ` <span>${comments.length}</span>` : ''}`;
            btn.dataset.line = currentLine;
            controlBox.appendChild(btn);

            const commentLineText = cleanText.length > 50 ? cleanText.substring(0, 50) + '...' : cleanText;
            const panel = document.createElement('div');
            panel.className = 'inline-panel';
            panel.hidden = true;
            panel.innerHTML = `
                <div class="inline-panel-header">
                    <span title="${cleanText}">${commentLineText}</span>
                    <button type="button" class="inline-close">√ó</button>
                </div>
                <div class="inline-comments">
                    ${comments.length > 0 ? comments.map(c => `
                        <div class="inline-comment">
                            <p style="white-space: pre-wrap; word-wrap: break-word;">${c.Content}</p>
                            <small>${c.AuthorName} ¬∑ ${c.CreatedAt}</small>
                        </div>
                    `).join('') : '<p class="inline-empty">Ch∆∞a c√≥ b√¨nh lu·∫≠n.</p>'}
                </div>
                ${isAuth ? `
                <form class="inline-form" data-line="${currentLine}">
                    <textarea placeholder="Th√™m b√¨nh lu·∫≠n..." required minlength="3"></textarea>
                    <button type="submit" class="btn primary small">G·ª≠i</button>
                    <p class="inline-error" hidden></p>
                </form>
                ` : ''}
            `;
            ensurePanelContainer(wrapper).appendChild(panel);
            blocks.push({ wrapper, btn, panel, lineNumber: currentLine });
        }
    });
    
    const closeAllCommentPanels = () => {
        blocks.forEach(b => {
            b.panel.hidden = true;
            b.wrapper.classList.remove('active');
        });
    };

    const closeAllAnnotationPanels = () => {
        annotationBlocks.forEach(b => {
            b.panel.hidden = true;
            b.wrapper.classList.remove('annotation-active');
        });
    };

    document.addEventListener('click', async (e) => {
        const annotateBtn = e.target.closest('.annotate-btn');
        const btn = e.target.closest('.inline-btn:not(.annotate-btn)');
        const close = e.target.closest('.inline-close');
        const cancelAnnotate = e.target.closest('.annotation-cancel');

        if (close) {
            e.preventDefault();
            e.stopPropagation();
            const panel = close.closest('.inline-panel');
            if (panel) {
                panel.hidden = true;
                const commentBlock = blocks.find(b => b.panel === panel);
                if (commentBlock) {
                    commentBlock.wrapper.classList.remove('active');
                }
                const annotationBlock = annotationBlocks.find(b => b.panel === panel);
                if (annotationBlock) {
                    annotationBlock.wrapper.classList.remove('annotation-active');
                }
            }
            return;
        }

        if (cancelAnnotate) {
            e.preventDefault();
            const panel = cancelAnnotate.closest('.inline-panel');
            if (panel) {
                panel.hidden = true;
                const annotationBlock = annotationBlocks.find(b => b.panel === panel);
                if (annotationBlock) {
                    annotationBlock.wrapper.classList.remove('annotation-active');
                    annotationBlock.textarea.value = lineAnnotations[annotationBlock.lineNumber] || '';
                }
            }
            return;
        }

        if (annotateBtn) {
            e.preventDefault();
            e.stopPropagation();
            const line = parseInt(annotateBtn.dataset.line);
            const block = annotationBlocks.find(b => b.lineNumber === line);
            if (block) {
                const wasHidden = block.panel.hidden;
                closeAllCommentPanels();
                closeAllAnnotationPanels();
                if (wasHidden) {
                    // Position panel at click location
                    const rect = annotateBtn.getBoundingClientRect();
                    block.panel.style.left = `${rect.left}px`;
                    block.panel.style.top = `${rect.bottom + 5}px`;
                    
                    block.panel.hidden = false;
                    block.wrapper.classList.add('annotation-active');
                    block.textarea.value = lineAnnotations[line] || '';
                    setTimeout(() => block.textarea.focus(), 0);
                }
            }
            return;
        }

        if (btn) {
            e.preventDefault();
            e.stopPropagation();
            const line = parseInt(btn.dataset.line);
            const block = blocks.find(b => b.lineNumber === line);
            if (block) {
                const wasHidden = block.panel.hidden;
                closeAllAnnotationPanels();
                blocks.forEach(b => {
                    b.panel.hidden = true;
                    b.wrapper.classList.remove('active');
                });
                if (wasHidden) {
                    // Position panel at click location
                    const rect = btn.getBoundingClientRect();
                    block.panel.style.left = `${rect.left}px`;
                    block.panel.style.top = `${rect.bottom + 5}px`;
                    
                    block.panel.hidden = false;
                    block.wrapper.classList.add('active');
                }
            }
            return;
        }

        if (!e.target.closest('.inline-panel')) {
            closeAllCommentPanels();
            closeAllAnnotationPanels();
        }
    });

    if (isAuth || isAuthor) {
        document.addEventListener('submit', async (e) => {
            const form = e.target;
            if (!form.classList.contains('inline-form') && !form.classList.contains('annotation-form')) return;
            e.preventDefault();
            
            const line = parseInt(form.dataset.line);
            const textarea = form.querySelector('textarea');
            const error = form.querySelector('.inline-error');
            const submitBtn = form.querySelector('button[type="submit"]');

            error.hidden = true;
            const content = textarea.value.trim();

            if (form.classList.contains('inline-form')) {
                if (content.length < 3) {
                    error.textContent = 'B√¨nh lu·∫≠n ph·∫£i t·ª´ 3 k√Ω t·ª±.';
                    error.hidden = false;
                    return;
                }

                submitBtn.disabled = true;
                try {
                    const res = await fetch(`/posts/${postId}/comments`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ content, line_number: parseInt(line) })
                    });

                    if (!res.ok) throw new Error('Kh√¥ng th·ªÉ g·ª≠i b√¨nh lu·∫≠n');
                    
                    const data = await res.json();
                    const commentsDiv = form.previousElementSibling;
                    const empty = commentsDiv.querySelector('.inline-empty');
                    if (empty) empty.remove();

                    const newComment = document.createElement('div');
                    newComment.className = 'inline-comment new';
                    newComment.innerHTML = `
                        <p style="white-space: pre-wrap; word-wrap: break-word;">${data.comment.content}</p>
                        <small>${data.comment.author_name} ¬∑ ${data.comment.created_at}</small>
                    `;
                    commentsDiv.appendChild(newComment);
                    textarea.value = '';

                    const block = blocks.find(b => b.lineNumber === line);
                    if (block) {
                        block.wrapper.classList.add('highlight');
                        setTimeout(() => block.wrapper.classList.remove('highlight'), 2000);
                        const countSpan = block.btn.querySelector('span');
                        if (countSpan) {
                            countSpan.textContent = parseInt(countSpan.textContent) + 1;
                        } else {
                            block.btn.innerHTML += ` <span>1</span>`;
                        }
                    }
                } catch (err) {
                    error.textContent = err.message;
                    error.hidden = false;
                } finally {
                    submitBtn.disabled = false;
                }
                return;
            }

            // Annotation form handling
            const currentAnnotation = lineAnnotations[line] || '';
            if (content === currentAnnotation) {
                const block = annotationBlocks.find(b => b.lineNumber === line);
                if (block) {
                    block.panel.hidden = true;
                    block.wrapper.classList.remove('annotation-active');
                }
                return;
            }

            submitBtn.disabled = true;
            try {
                const res = await fetch(`/posts/${postId}/annotations`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ content, line_number: line })
                });

                if (!res.ok) {
                    const errorData = await res.json();
                    console.error('Error response:', errorData);
                    throw new Error(errorData.error || 'Kh√¥ng th·ªÉ l∆∞u ch√∫ th√≠ch');
                }

                lineAnnotations[line] = content;

                const block = annotationBlocks.find(b => b.lineNumber === line);
                if (block) {
                    block.panel.hidden = true;
                    block.wrapper.classList.remove('annotation-active');
                }

                const wrapper = document.querySelector(`.inline-line[data-line="${line}"]`);
                if (wrapper) {
                    // Live update: C·∫≠p nh·∫≠t n·ªôi dung #... trong DOM
                    const contentHolder = wrapper.querySelector('.inline-line-content');
                    if (contentHolder) {
                        // T√¨m v√† x√≥a #... c≈©
                        const textNodes = [];
                        const walker = document.createTreeWalker(contentHolder, NodeFilter.SHOW_TEXT, null);
                        while (walker.nextNode()) textNodes.push(walker.currentNode);
                        
                        let found = false;
                        for (let i = textNodes.length - 1; i >= 0; i--) {
                            const node = textNodes[i];
                            // Match # followed by space
                            if (node.textContent.match(/#\s+[^#]*$/)) {
                                const newText = content 
                                    ? node.textContent.replace(/#\s+[^#]*$/, '').trim() + ' # ' + content
                                    : node.textContent.replace(/\s*#\s+[^#]*$/, '').trim();
                                node.textContent = newText;
                                found = true;
                                break;
                            }
                        }
                        
                        // N·∫øu kh√¥ng t√¨m th·∫•y # ... c≈© v√† c√≥ n·ªôi dung m·ªõi, th√™m v√†o cu·ªëi
                        if (!found && content) {
                            const lastTextNode = textNodes[textNodes.length - 1];
                            if (lastTextNode) {
                                lastTextNode.textContent = lastTextNode.textContent.trim() + ' # ' + content;
                            } else if (contentHolder.lastChild) {
                                contentHolder.appendChild(document.createTextNode(' # ' + content));
                            }
                        }
                    }

                    // C·∫≠p nh·∫≠t hi·ªÉn th·ªã annotation span
                    let annotationSpan = wrapper.querySelector('.line-annotation');
                    if (content) {
                        if (!annotationSpan) {
                            annotationSpan = document.createElement('span');
                            annotationSpan.className = 'line-annotation';
                            wrapper.appendChild(annotationSpan);
                        }
                        annotationSpan.textContent = `# ${content}`;
                        annotationSpan.title = content;
                        
                        // Add highlight effect for live update
                        wrapper.classList.add('annotation-highlight');
                        setTimeout(() => wrapper.classList.remove('annotation-highlight'), 2000);
                    } else if (annotationSpan) {
                        annotationSpan.remove();
                    }
                    
                    // Update textarea value in the panel
                    const block = annotationBlocks.find(b => b.lineNumber === line);
                    if (block && block.textarea) {
                        block.textarea.value = content;
                    }
                    
                    // Update postBody HTML for edit form
                    // C·∫≠p nh·∫≠t n·ªôi dung trong postBody ƒë·ªÉ khi m·ªü editor s·∫Ω c√≥ gi√° tr·ªã m·ªõi
                    const editTextarea = document.getElementById('edit-content-textarea');
                    if (editTextarea) {
                        editTextarea.value = postBody.innerHTML;
                    }
                    
                    // Live update Quill editor if it's already initialized
                    if (editQuill) {
                        const delta = editQuill.clipboard.convert(postBody.innerHTML);
                        editQuill.setContents(delta, 'silent');
                    }
                }
            } catch (err) {
                error.textContent = err.message;
                error.hidden = false;
            } finally {
                submitBtn.disabled = false;
            }
        });
    }
});
</script>
