<article class="post-detail">
    <header class="hero hero-basic">
        <div class="hero-header">
            <div class="hero-text">
                <h1>{{.Post.Title}}</h1>
                <p class="meta">B·ªüi {{.Post.AuthorName}} ¬∑ {{.Post.CreatedLabel}}</p>
            </div>
        </div>
        {{if .Post.Summary}}
        <p class="summary">{{.Post.Summary}}</p>
        {{end}}
        
    </header>
    {{if .IsAuthor}}
    <section class="card post-editor" id="post-editor" hidden>
        <div class="composer-grid">
            <form method="post" action="/posts/{{.Post.ID}}/edit" class="stack" id="post-edit-form">
                <label>T·ª±a ƒë·ªÅ
                    <input type="text" name="title" value="{{.Post.Title}}" placeholder="Ti√™u ƒë·ªÅ b√†i vi·∫øt" required minlength="3" data-preview="title">
                </label>
                <label>T√≥m t·∫Øt ng·∫Øn
                    <input type="text" name="summary" value="{{.Post.Summary}}" placeholder="T√≥m t·∫Øt ng·∫Øn g·ªçn" data-preview="summary">
                </label>
                <label>·∫¢nh b√¨a (URL)
                    <input type="url" name="cover_url" value="{{.Post.CoverURL}}" placeholder="https://example.com/cover.jpg" data-preview="cover">
                </label>
                <label>Tags (ph√¢n lo·∫°i)
                    <input type="text" name="tags" value="{{.Post.Tags}}" placeholder="docker, kubernetes, ci-cd" data-preview="tags">
                    <small style="color: #94a3b8; font-size: 0.85rem;">Nh·∫≠p c√°c tags c√°ch nhau b·∫±ng d·∫•u ph·∫©y</small>
                </label>
                <label>N·ªôi dung b√†i vi·∫øt
                    <div id="edit-editor-container" style="min-height: 300px; background: rgba(15, 23, 42, 0.65); border: 1px solid rgba(148, 163, 184, 0.3); border-radius: 8px;"></div>
                    <textarea name="content" id="edit-content-textarea" hidden required minlength="10">{{.Post.Content}}</textarea>
                    <input type="hidden" name="line_annotations" id="edit-line-annotations">
                </label>
                <div class="form-actions">
                    <button type="button" class="btn ghost" id="edit-preview-btn">üëÅÔ∏è Xem tr∆∞·ªõc</button>
                    <button type="submit" class="btn primary">L∆∞u thay ƒë·ªïi</button>
                    <button type="button" class="btn ghost" data-action="close-editor">H·ªßy</button>
                </div>
            </form>
            <aside class="preview" id="post-edit-notice">
                <h3 class="preview-heading">Ghi ch√∫</h3>
                <p style="color: #94a3b8; font-size: 0.85rem; margin-bottom: 0.5rem;">Th√™m ghi ch√∫ cho t·ª´ng d√≤ng trong b√†i vi·∫øt</p>
                
                <!-- Search box -->
                <div style="margin-bottom: 1rem;">
                    <input 
                        type="text" 
                        id="edit-notice-search" 
                        placeholder="T√¨m ki·∫øm theo d√≤ng ho·∫∑c n·ªôi dung..." 
                        style="width: 95%; padding: 0.5rem; background: rgba(15, 23, 42, 0.6); border: 1px solid rgba(148, 163, 184, 0.3); border-radius: 6px; color: #e2e8f0; font-size: 0.9rem;"
                    >
                </div>
                
                <div id="edit-notice-list" style="display: flex; flex-direction: column; gap: 0.75rem; max-height: 500px; overflow-y: auto;">
                    <!-- Notice items will be added here dynamically -->
                </div>
            </aside>
        </div>
    </section>
    {{end}}
    
    <div class="post-meta-actions">
        {{if .Post.Tags}}
        <div class="post-tags">
            {{range .PostTags}}
            <a href="/posts?tag={{.}}" class="tag-badge">{{.}}</a>
            {{end}}
        </div>
        {{end}}
        {{if .IsAuthor}}
        <div class="post-author-actions">
            <button type="button" class="btn ghost" data-action="toggle-editor">Ch·ªânh s·ª≠a b√†i vi·∫øt</button>
        </div>
        {{end}}
    </div>
    
    <section class="card post-body" id="post-body" data-post-id="{{.Post.ID}}" data-auth="{{if .IsAuthenticated}}true{{else}}false{{end}}">
        {{.Post.Content | safeHTML}}
    </section>
    <div class="post-image-lightbox" id="post-image-lightbox" aria-hidden="true">
        <figure class="lightbox-content">
            <button type="button" class="lightbox-close" aria-label="ƒê√≥ng" data-action="close-lightbox">√ó</button>
            <img src="" alt="·∫¢nh ph√≥ng to" loading="lazy">
            <figcaption hidden></figcaption>
        </figure>
    </div>
</article>
{{if .IsAuthor}}
<link href="https://cdn.quilljs.com/1.3.7/quill.snow.css" rel="stylesheet">
<link href="https://cdn.quilljs.com/1.3.7/quill.bubble.css" rel="stylesheet">
<script src="https://cdn.quilljs.com/1.3.7/quill.min.js"></script>
<style>
.ql-snow .ql-picker.ql-expanded .ql-picker-label {
    border-color: rgba(148, 163, 184, 0.5);
}
.ql-snow .ql-picker.ql-expanded .ql-picker-options {
    display: block;
    background: rgba(15, 23, 42, 0.98);
    border: 1px solid rgba(148, 163, 184, 0.3);
    border-radius: 8px;
    margin-top: 2px;
}
.ql-snow .ql-color-picker .ql-picker-item {
    border: 1px solid rgba(148, 163, 184, 0.2);
}
.ql-snow .ql-picker-options {
    z-index: 100;
}
.ql-snow .ql-picker-label:active,
.ql-snow .ql-picker-label:focus {
    outline: none;
}
.ql-toolbar.ql-snow .ql-picker.ql-expanded .ql-picker-options {
    display: block !important;
    opacity: 1 !important;
    visibility: visible !important;
}
</style>
{{end}}
<script>
window.LINE_COMMENTS = {{.LineComments | json}};
window.LINE_ANNOTATIONS = {{.LineAnnotations | json}};
window.IS_AUTHOR = {{.IsAuthor}};
</script>
<section class="comments" id="comments">
    <header class="section-header">
        <h2>B√¨nh lu·∫≠n</h2>
        <p>Th·∫£o lu·∫≠n v√† ƒë√≥ng g√≥p √Ω ki·∫øn c·ªßa b·∫°n ƒë·ªÉ c√πng c·∫£i thi·ªán quy tr√¨nh DevOps.</p>
    </header>
    {{if .GeneralComments}}
    <div class="stack comment-list">
        {{range .GeneralComments}}
        <article class="card comment-card">
            <p style="white-space: pre-wrap; word-wrap: break-word;">{{.Content}}</p>
            <p class="meta">B·ªüi {{.AuthorName}} ¬∑ {{.CreatedAt}}</p>
        </article>
        {{end}}
    </div>
    {{else}}
    <p class="empty">Ch∆∞a c√≥ b√¨nh lu·∫≠n chung. H√£y m·ªü ƒë·∫ßu cu·ªôc tr√≤ chuy·ªán!</p>
    {{end}}
</section>
<section class="comment-form card" id="add-comment">
    <h3>ƒê√≥ng g√≥p b√¨nh lu·∫≠n</h3>
    {{if .IsAuthenticated}}
    <form method="post" action="/posts/{{.Post.ID}}/comments" class="stack">
        <textarea name="content" rows="4" placeholder="Chia s·∫ª kinh nghi·ªám, b√†i h·ªçc, ho·∫∑c c√¢u h·ªèi c·ªßa b·∫°n" required minlength="3"></textarea>
        <button type="submit" class="btn primary">G·ª≠i b√¨nh lu·∫≠n</button>
    </form>
    {{else}}
    <p>B·∫°n c·∫ßn <a href="/auth/login?next=/posts/{{.Post.ID}}#add-comment">ƒëƒÉng nh·∫≠p</a> ƒë·ªÉ b√¨nh lu·∫≠n. Ch∆∞a c√≥ t√†i kho·∫£n? <a href="/auth/register?next=/posts/{{.Post.ID}}#add-comment">ƒêƒÉng k√Ω ngay</a>.</p>
    {{end}}
</section>
<script>
document.addEventListener('DOMContentLoaded', () => {
    const postBody = document.getElementById('post-body');
    if (!postBody) return;

    const postId = postBody.dataset.postId;
    const isAuth = postBody.dataset.auth === 'true';
    const lineComments = window.LINE_COMMENTS || {};
    const lineAnnotations = window.LINE_ANNOTATIONS || {};
    const isAuthor = window.IS_AUTHOR || false;
    
    const lightbox = document.getElementById('post-image-lightbox');
    const lightboxImg = lightbox?.querySelector('img');
    const lightboxCaption = lightbox?.querySelector('figcaption');
    const lightboxCloseBtn = lightbox?.querySelector('[data-action="close-lightbox"]');

    const openLightbox = (img) => {
        if (!lightbox || !lightboxImg) return;
        const fullSrc = img.getAttribute('data-full-src') || img.currentSrc || img.src;
        lightboxImg.src = fullSrc;
        lightboxImg.alt = img.alt || '·∫¢nh ph√≥ng to';
        if (lightboxCaption) {
            const caption = img.getAttribute('alt') || img.getAttribute('title') || '';
            if (caption) {
                lightboxCaption.textContent = caption;
                lightboxCaption.hidden = false;
            } else {
                lightboxCaption.hidden = true;
                lightboxCaption.textContent = '';
            }
        }
        lightbox.removeAttribute('data-zoomed');
        lightbox.setAttribute('data-active', 'true');
        lightbox.setAttribute('aria-hidden', 'false');
        document.body.classList.add('lightbox-open');
    };

    const closeLightbox = () => {
        if (!lightbox || !lightboxImg) return;
        lightbox.removeAttribute('data-active');
        lightbox.removeAttribute('data-zoomed');
        lightbox.setAttribute('aria-hidden', 'true');
        document.body.classList.remove('lightbox-open');
        setTimeout(() => {
            lightboxImg.src = '';
        }, 200);
    };

    const toggleZoom = () => {
        if (!lightbox) return;
        const isZoomed = lightbox.getAttribute('data-zoomed') === 'true';
        if (isZoomed) {
            lightbox.removeAttribute('data-zoomed');
        } else {
            lightbox.setAttribute('data-zoomed', 'true');
        }
    };

    if (lightbox) {
        lightbox.addEventListener('click', (event) => {
            if (event.target === lightbox) {
                closeLightbox();
            }
        });
    }

    lightboxCloseBtn?.addEventListener('click', closeLightbox);
    lightboxImg?.addEventListener('click', toggleZoom);

    document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape' && lightbox?.getAttribute('data-active') === 'true') {
            closeLightbox();
        }
    });

    const attachLightbox = (root) => {
        if (!root) return;
        root.querySelectorAll('img').forEach((img) => {
            if (img.dataset.lightboxBound === 'true') return;
            img.dataset.lightboxBound = 'true';
            img.addEventListener('click', () => openLightbox(img));
        });
    };

    attachLightbox(postBody);

    // Global reference to Quill editor for live updates
    let editQuill = null;

    if (isAuthor) {
        const toggleEditorBtn = document.querySelector('[data-action="toggle-editor"]');
        const editorSection = document.getElementById('post-editor');
        const postBodySection = document.getElementById('post-body');
        const closeEditorBtn = document.querySelector('[data-action="close-editor"]');
        const editForm = document.getElementById('post-edit-form');
        const noticeList = document.getElementById('edit-notice-list');

        if (toggleEditorBtn && editorSection && postBodySection && editForm && noticeList) {
            const textarea = editForm.querySelector('#edit-content-textarea');
            const defaultSummary = 'T√≥m t·∫Øt s·∫Ω gi√∫p ng∆∞·ªùi ƒë·ªçc hi·ªÉu nhanh n·ªôi dung ch√≠nh c·ªßa b√†i vi·∫øt.';
            const defaultContent = '<p>N·ªôi dung b√†i vi·∫øt hi·ªÉn th·ªã theo t·ª´ng ƒëo·∫°n...</p>';

            // Initialize Quill editor for edit mode
            if (window.Quill && document.getElementById('edit-editor-container')) {
                editQuill = new Quill('#edit-editor-container', {
                    theme: 'snow',
                    placeholder: 'Ch·ªânh s·ª≠a n·ªôi dung b√†i vi·∫øt...',
                    modules: {
                        toolbar: [
                            [{ 'header': [1, 2, 3, false] }],
                            ['bold', 'italic', 'underline', 'strike'],
                            [{ 'color': [] }, { 'background': [] }],
                            [{ 'list': 'ordered'}, { 'list': 'bullet' }],
                            [{ 'indent': '-1'}, { 'indent': '+1' }],
                            ['link', 'image'],
                            ['clean']
                        ],
                        keyboard: {
                            bindings: {
                                linebreak: {
                                    key: 13,
                                    shiftKey: true,
                                    handler: function(range) {
                                        this.quill.insertText(range.index, '\n', 'user');
                                        this.quill.setSelection(range.index + 1);
                                        return false;
                                    }
                                }
                            }
                        },
                        clipboard: {
                            matchVisual: false
                        }
                    }
                });

                // Create custom bubble toolbar for text selection
                const bubbleToolbar = document.createElement('div');
                bubbleToolbar.className = 'custom-bubble-toolbar';
                bubbleToolbar.style.cssText = 'position: absolute; display: none; z-index: 1000; background: rgba(15, 23, 42, 0.98); border: 1px solid rgba(148, 163, 184, 0.3); border-radius: 8px; padding: 4px; box-shadow: 0 4px 12px rgba(0,0,0,0.3);';
                bubbleToolbar.innerHTML = `
                    <select class="ql-size" title="Font Size" style="width: 70px; height: 28px; border: 1px solid rgba(148, 163, 184, 0.3); background: rgba(30, 41, 59, 0.8); color: #94a3b8; border-radius: 4px; cursor: pointer; font-size: 0.85rem;">
                        <option value="small">Nh·ªè</option>
                        <option selected>B√¨nh th∆∞·ªùng</option>
                        <option value="large">L·ªõn</option>
                        <option value="huge">R·∫•t l·ªõn</option>
                    </select>
                    <button type="button" class="ql-bold" title="Bold" style="width: 28px; height: 28px; border: none; background: transparent; color: #94a3b8; cursor: pointer; border-radius: 4px;"><b>B</b></button>
                    <button type="button" class="ql-italic" title="Italic" style="width: 28px; height: 28px; border: none; background: transparent; color: #94a3b8; cursor: pointer; border-radius: 4px;"><i>I</i></button>
                    <button type="button" class="ql-underline" title="Underline" style="width: 28px; height: 28px; border: none; background: transparent; color: #94a3b8; cursor: pointer; border-radius: 4px;"><u>U</u></button>
                    <button type="button" class="ql-strike" title="Strike" style="width: 28px; height: 28px; border: none; background: transparent; color: #94a3b8; cursor: pointer; border-radius: 4px;"><s>S</s></button>
                    <button type="button" class="ql-link" title="Link" style="width: 28px; height: 28px; border: none; background: transparent; color: #94a3b8; cursor: pointer; border-radius: 4px;">üîó</button>
                    <select class="ql-color" title="Text Color" style="width: 60px; height: 28px; border: 1px solid rgba(148, 163, 184, 0.3); background: rgba(30, 41, 59, 0.8); color: #94a3b8; border-radius: 4px; cursor: pointer;">
                        <option value="#e2e8f0" selected>Default</option>
                        <option value="#38bdf8">Blue</option>
                        <option value="#ffffff">White</option>
                        <option value="#22c55e">Green</option>
                        <option value="#ef4444">Red</option>
                        <option value="#f59e0b">Orange</option>
                    </select>
                `;
                document.body.appendChild(bubbleToolbar);

                // Handle bubble toolbar button clicks
                bubbleToolbar.querySelectorAll('button').forEach(btn => {
                    btn.addEventListener('mousedown', (e) => {
                        e.preventDefault();
                        const format = btn.className.replace('ql-', '');
                        const currentFormat = editQuill.getFormat();
                        if (format === 'link') {
                            const url = prompt('Enter URL:');
                            if (url) {
                                editQuill.format('link', url);
                            }
                        } else {
                            editQuill.format(format, !currentFormat[format]);
                        }
                    });
                    btn.addEventListener('mouseenter', () => {
                        btn.style.background = 'rgba(56, 189, 248, 0.2)';
                    });
                    btn.addEventListener('mouseleave', () => {
                        btn.style.background = 'transparent';
                    });
                });

                // Handle font size select
                const sizeSelect = bubbleToolbar.querySelector('.ql-size');
                sizeSelect.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                });
                sizeSelect.addEventListener('change', (e) => {
                    e.preventDefault();
                    const selection = editQuill.getSelection();
                    if (selection && selection.length > 0) {
                        const value = e.target.value;
                        if (value) {
                            editQuill.format('size', value);
                        } else {
                            // Remove size formatting to return to normal
                            editQuill.removeFormat(selection.index, selection.length);
                            // Reapply other formats that were there
                            const formats = editQuill.getFormat(selection);
                            Object.keys(formats).forEach(key => {
                                if (key !== 'size') {
                                    editQuill.formatText(selection.index, selection.length, key, formats[key]);
                                }
                            });
                        }
                    }
                });

                // Handle color select
                bubbleToolbar.querySelector('.ql-color').addEventListener('change', (e) => {
                    editQuill.format('color', e.target.value);
                });

                // Function to update and show bubble toolbar
                function updateEditBubbleToolbar() {
                    const selection = window.getSelection();
                    if (!selection || selection.rangeCount === 0) {
                        bubbleToolbar.style.display = 'none';
                        return;
                    }

                    const range = selection.getRangeAt(0);
                    const editorContainer = document.getElementById('edit-editor-container');
                    
                    // Check if selection is within editor
                    if (!editorContainer.contains(range.commonAncestorContainer)) {
                        bubbleToolbar.style.display = 'none';
                        return;
                    }

                    // Check if there's actual text selected
                    if (selection.toString().trim().length === 0) {
                        bubbleToolbar.style.display = 'none';
                        return;
                    }

                    // Get selection bounds
                    const rect = range.getBoundingClientRect();
                    
                    // Get Quill format for the selection
                    const quillSelection = editQuill.getSelection();
                    if (quillSelection) {
                        const currentFormat = editQuill.getFormat(quillSelection);
                        
                        // Update size select
                        const sizeSelect = bubbleToolbar.querySelector('.ql-size');
                        if (currentFormat.size) {
                            sizeSelect.value = currentFormat.size;
                        } else {
                            sizeSelect.value = ''; // Normal/default size
                        }
                        
                        // Update color select
                        const colorSelect = bubbleToolbar.querySelector('.ql-color');
                        if (currentFormat.color) {
                            colorSelect.value = currentFormat.color;
                        } else {
                            colorSelect.value = '#e2e8f0'; // Default color
                        }
                    }
                    
                    // Position and show bubble toolbar
                    bubbleToolbar.style.display = 'flex';
                    bubbleToolbar.style.gap = '2px';
                    bubbleToolbar.style.left = (rect.left + (rect.width / 2) - (bubbleToolbar.offsetWidth / 2)) + 'px';
                    bubbleToolbar.style.top = (rect.top - bubbleToolbar.offsetHeight - 8 + window.scrollY) + 'px';
                }

                // Listen to both Quill and native selection changes
                editQuill.on('selection-change', (range) => {
                    if (range && range.length > 0) {
                        updateEditBubbleToolbar();
                    } else {
                        bubbleToolbar.style.display = 'none';
                    }
                });

                // Also listen to native selectionchange for multiple selections
                const handleEditSelectionChange = () => {
                    const selection = window.getSelection();
                    const editorContainer = document.getElementById('edit-editor-container');
                    
                    if (!editorContainer || !selection) return;
                    
                    // Check if there's any text selected
                    const selectedText = selection.toString().trim();
                    if (selectedText.length > 0 && selection.rangeCount > 0) {
                        const range = selection.getRangeAt(0);
                        
                        // Check if selection is within editor
                        if (editorContainer.contains(range.commonAncestorContainer)) {
                            // Use longer delay to ensure selection is stable
                            setTimeout(() => {
                                // Double check selection still exists
                                const currentSelection = window.getSelection();
                                if (currentSelection && currentSelection.toString().trim().length > 0) {
                                    updateEditBubbleToolbar();
                                }
                            }, 50);
                        }
                    }
                };
                
                // Remove any existing listener first
                document.removeEventListener('selectionchange', handleEditSelectionChange);
                document.addEventListener('selectionchange', handleEditSelectionChange);
                
                // Also listen to mouseup for immediate response
                editEditorContainer.addEventListener('mouseup', (e) => {
                    setTimeout(() => {
                        const selection = window.getSelection();
                        if (selection && selection.toString().trim().length > 0) {
                            updateEditBubbleToolbar();
                        }
                    }, 50);
                });

                // Hide bubble toolbar when clicking outside
                document.addEventListener('click', (e) => {
                    if (!bubbleToolbar.contains(e.target) && !document.getElementById('edit-editor-container').contains(e.target)) {
                        bubbleToolbar.style.display = 'none';
                    }
                });

                // Prevent scroll on paste - maintain cursor position
                const editEditorContainer = document.getElementById('edit-editor-container');
                let isPasting = false;
                let savedScrollPos = 0;
                let savedSelection = null;
                let scrollLockTimer = null;
                
                // Save position before paste
                editEditorContainer.addEventListener('paste', function(e) {
                    isPasting = true;
                    savedScrollPos = window.scrollY;
                    savedSelection = editQuill.getSelection();
                    
                    // Lock scroll position for a short time
                    const lockScroll = () => {
                        if (isPasting) {
                            window.scrollTo({
                                top: savedScrollPos,
                                behavior: 'instant'
                            });
                        }
                    };
                    
                    // Continuously lock scroll for 100ms
                    scrollLockTimer = setInterval(lockScroll, 10);
                    setTimeout(() => {
                        if (scrollLockTimer) {
                            clearInterval(scrollLockTimer);
                            scrollLockTimer = null;
                        }
                    }, 100);
                });
                
                // Restore position after Quill processes the paste
                editQuill.on('text-change', function(delta, oldDelta, source) {
                    if (isPasting) {
                        requestAnimationFrame(() => {
                            // Restore scroll
                            window.scrollTo({
                                top: savedScrollPos,
                                behavior: 'instant'
                            });
                            // Keep cursor at paste location
                            if (savedSelection) {
                                const newPos = savedSelection.index + (delta.ops[0]?.insert?.length || 0);
                                editQuill.setSelection(newPos, 0);
                            }
                        });
                        isPasting = false;
                        if (scrollLockTimer) {
                            clearInterval(scrollLockTimer);
                            scrollLockTimer = null;
                        }
                    }
                });

                // Load existing content from postBody (which includes annotations)
                // Use postBody.innerHTML instead of textarea to preserve annotations
                const postBodyContent = document.querySelector('.post-body');
                if (postBodyContent) {
                    const delta = editQuill.clipboard.convert(postBodyContent.innerHTML);
                    editQuill.setContents(delta, 'silent');
                    // Update textarea to match
                    textarea.value = postBodyContent.innerHTML;
                } else if (textarea && textarea.value) {
                    const delta = editQuill.clipboard.convert(textarea.value);
                    editQuill.setContents(delta, 'silent');
                }

                // Fix picker dropdowns by stopping Quill's default toggle behavior
                setTimeout(() => {
                    const toolbar = document.querySelector('#edit-editor-container')?.previousElementSibling;
                    if (!toolbar) return;
                    
                    const pickers = toolbar.querySelectorAll('.ql-picker');
                    pickers.forEach(picker => {
                        const label = picker.querySelector('.ql-picker-label');
                        if (!label) return;
                        
                        // Stop all events on the label to prevent Quill's handler
                        label.addEventListener('click', function(e) {
                            e.stopImmediatePropagation();
                            
                            // Manually toggle
                            const isExpanded = picker.classList.contains('ql-expanded');
                            
                            // Close all pickers first
                            pickers.forEach(p => p.classList.remove('ql-expanded'));
                            
                            // Open this one if it wasn't open
                            if (!isExpanded) {
                                picker.classList.add('ql-expanded');
                            }
                        }, true);
                        
                        // Prevent mousedown from bubbling
                        label.addEventListener('mousedown', function(e) {
                            e.preventDefault();
                            e.stopImmediatePropagation();
                        }, true);
                    });
                    
                    // Close when clicking outside
                    document.addEventListener('click', function(e) {
                        if (!e.target.closest('.ql-picker')) {
                            pickers.forEach(p => p.classList.remove('ql-expanded'));
                        }
                    });
                }, 300);

                // Sync Quill to textarea and update notice sidebar
                editQuill.on('text-change', function() {
                    let html = editQuill.root.innerHTML;
                    // Replace text nodes containing \n with <br> tags
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = html;
                    
                    // Walk through all text nodes and replace \n with <br>
                    const walker = document.createTreeWalker(tempDiv, NodeFilter.SHOW_TEXT, null, false);
                    const nodesToReplace = [];
                    while (walker.nextNode()) {
                        const node = walker.currentNode;
                        if (node.nodeValue && node.nodeValue.includes('\n')) {
                            nodesToReplace.push(node);
                        }
                    }
                    
                    nodesToReplace.forEach(node => {
                        const parts = node.nodeValue.split('\n');
                        const fragment = document.createDocumentFragment();
                        parts.forEach((part, i) => {
                            fragment.appendChild(document.createTextNode(part));
                            if (i < parts.length - 1) {
                                fragment.appendChild(document.createElement('br'));
                            }
                        });
                        node.parentNode.replaceChild(fragment, node);
                    });
                    
                    html = tempDiv.innerHTML;
                    textarea.value = html;
                    
                    // Update notice sidebar
                    updateEditNoticeInputs();
                });

                // Image upload handler
                editQuill.getModule('toolbar').addHandler('image', function() {
                    const input = document.createElement('input');
                    input.setAttribute('type', 'file');
                    input.setAttribute('accept', 'image/*');
                    input.click();

                    input.onchange = async function() {
                        const file = input.files[0];
                        if (!file) return;

                        const formData = new FormData();
                        formData.append('image', file);

                        try {
                            const response = await fetch('/upload/image', {
                                method: 'POST',
                                body: formData
                            });

                            if (!response.ok) {
                                throw new Error('Upload th·∫•t b·∫°i');
                            }

                            const data = await response.json();
                            const range = editQuill.getSelection(true);
                            editQuill.insertEmbed(range.index, 'image', data.url);
                            editQuill.setSelection(range.index + 1);
                        } catch (error) {
                            alert('L·ªói upload ·∫£nh: ' + error.message);
                        }
                    };
                });
            }

            // Function to update notice sidebar
            function updateEditNoticeInputs() {
                if (!editQuill || !noticeList) return;

                requestAnimationFrame(() => {
                    const lines = editQuill.root.querySelectorAll('p, h1, h2, h3, h4, h5, h6, li');
                    const existingNotices = {};
                    
                    // First, load from lineAnnotations (from backend)
                    Object.keys(lineAnnotations).forEach(lineNum => {
                        existingNotices[lineNum] = lineAnnotations[lineNum];
                    });
                    
                    // Then preserve existing notice values from inputs (override if changed)
                    noticeList.querySelectorAll('input[data-line]').forEach(input => {
                        if (input.value.trim()) {
                            existingNotices[input.dataset.line] = input.value.trim();
                        }
                    });

                    noticeList.innerHTML = '';

                    let lineNum = 0; // Counter for non-empty lines only
                    lines.forEach((line, index) => {
                        const lineText = line.textContent.trim();
                        if (!lineText) return; // Skip empty lines without incrementing counter
                        
                        lineNum++; // Increment only for non-empty lines

                        const noticeItem = document.createElement('div');
                        noticeItem.className = 'notice-item';
                        noticeItem.dataset.line = lineNum;
                        noticeItem.style.cssText = 'display: flex; flex-direction: column; gap: 0.5rem; padding: 0.75rem; background: rgba(15, 23, 42, 0.6); border: 1px solid rgba(148, 163, 184, 0.2); border-radius: 6px;';

                        const linePreview = document.createElement('div');
                        linePreview.style.cssText = 'font-size: 0.85rem; color: #94a3b8;';
                        linePreview.innerHTML = `<strong style="color: #38bdf8;">D√≤ng ${lineNum}:</strong> ${lineText.substring(0, 50)}${lineText.length > 50 ? '...' : ''}`;

                        const noticeInput = document.createElement('input');
                        noticeInput.type = 'text';
                        noticeInput.dataset.line = lineNum;
                        noticeInput.placeholder = `Ghi ch√∫ cho d√≤ng ${lineNum}...`;
                        noticeInput.value = existingNotices[lineNum] || '';
                        noticeInput.style.cssText = 'padding: 0.5rem; background: rgba(30, 41, 59, 0.6); border: 1px solid rgba(148, 163, 184, 0.3); border-radius: 4px; color: #e2e8f0; font-size: 0.9rem;';

                        noticeItem.appendChild(linePreview);
                        noticeItem.appendChild(noticeInput);
                        noticeList.appendChild(noticeItem);
                    });
                });
            }

            // Search functionality
            const searchInput = document.getElementById('edit-notice-search');
            if (searchInput) {
                searchInput.addEventListener('input', (e) => {
                    const query = e.target.value.toLowerCase();
                    noticeList.querySelectorAll('.notice-item').forEach(item => {
                        const lineText = item.textContent.toLowerCase();
                        item.style.display = lineText.includes(query) ? 'flex' : 'none';
                    });
                });
            }

            const openEditor = () => {
                editorSection.hidden = false;
                postBodySection.hidden = true;
                if (toggleEditorBtn) toggleEditorBtn.disabled = true;
                
                // Load existing annotations into sidebar
                setTimeout(() => {
                    updateEditNoticeInputs();
                    // Annotations are now loaded inside updateEditNoticeInputs()
                }, 100);
                
                if (editQuill) {
                    editQuill.focus();
                }
            };

            const closeEditor = () => {
                editorSection.hidden = true;
                postBodySection.hidden = false;
                if (toggleEditorBtn) toggleEditorBtn.disabled = false;
            };

            toggleEditorBtn?.addEventListener('click', () => {
                openEditor();
            });

            closeEditorBtn?.addEventListener('click', () => {
                closeEditor();
            });

            // Sync notices to hidden field before submit
            editForm.addEventListener('submit', async function(e) {
                e.preventDefault();
                
                const submitBtn = editForm.querySelector('button[type="submit"]');
                const originalText = submitBtn.textContent;
                submitBtn.disabled = true;
                submitBtn.textContent = 'ƒêang l∆∞u...';
                
                try {
                    // Collect form data
                    const noticeData = {};
                    noticeList.querySelectorAll('input[data-line]').forEach(input => {
                        if (input.value.trim()) {
                            noticeData[input.dataset.line] = input.value.trim();
                        }
                    });
                    
                    // Encode content to base64 to avoid WAF pattern matching
                    const contentValue = editForm.querySelector('#edit-content-textarea').value;
                    const contentBase64 = btoa(unescape(encodeURIComponent(contentValue)));
                    
                    const payload = {
                        title: editForm.querySelector('input[name="title"]').value,
                        summary: editForm.querySelector('input[name="summary"]').value,
                        content_encoded: contentBase64,
                        cover_url: editForm.querySelector('input[name="cover_url"]').value,
                        tags: editForm.querySelector('input[name="tags"]').value,
                        line_annotations: JSON.stringify(noticeData)
                    };
                    
                    // Submit via fetch with JSON and base64 encoded content to avoid WAF issues
                    const response = await fetch(editForm.action, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Accept': 'application/json'
                        },
                        body: JSON.stringify(payload),
                        redirect: 'manual' // Don't auto-follow redirects
                    });
                    
                    if (response.ok) {
                        // Success - reload to show updated content
                        window.location.reload();
                    } else if (response.status === 403) {
                        throw new Error('Y√™u c·∫ßu b·ªã ch·∫∑n b·ªüi t∆∞·ªùng l·ª≠a. Vui l√≤ng th·ª≠ gi·∫£m ƒë·ªô d√†i n·ªôi dung ho·∫∑c li√™n h·ªá qu·∫£n tr·ªã vi√™n.');
                    } else {
                        // Try to parse error as JSON first
                        try {
                            const errorData = await response.json();
                            throw new Error(errorData.message || errorData.error || 'C√≥ l·ªói x·∫£y ra khi c·∫≠p nh·∫≠t b√†i vi·∫øt');
                        } catch (e) {
                            if (e.message && !e.message.includes('JSON')) {
                                throw e;
                            }
                            const error = await response.text();
                            throw new Error(error || 'C√≥ l·ªói x·∫£y ra khi c·∫≠p nh·∫≠t b√†i vi·∫øt');
                        }
                    }
                } catch (error) {
                    alert('L·ªói: ' + error.message);
                    submitBtn.disabled = false;
                    submitBtn.textContent = originalText;
                }
            });

            // Preview button handler
            const editPreviewBtn = document.getElementById('edit-preview-btn');
            if (editPreviewBtn) {
                editPreviewBtn.addEventListener('click', () => {
                    if (!editQuill) {
                        alert('Editor ch∆∞a s·∫µn s√†ng. Vui l√≤ng th·ª≠ l·∫°i.');
                        return;
                    }

                    const title = editForm.querySelector('input[name="title"]').value;
                    const summary = editForm.querySelector('input[name="summary"]').value;
                    const coverUrl = editForm.querySelector('input[name="cover_url"]').value;
                    const tags = editForm.querySelector('input[name="tags"]').value;
                    const content = editQuill.root.innerHTML;
                    
                    const lineAnnotationsData = {};
                    noticeList.querySelectorAll('input[data-line]').forEach(input => {
                        if (input.value.trim()) {
                            lineAnnotationsData[input.dataset.line] = input.value.trim();
                        }
                    });
                    
                    const authorName = '{{.Post.AuthorName}}';
                    
                    const previewData = {
                        title: title || 'Ti√™u ƒë·ªÅ b√†i vi·∫øt',
                        summary: summary,
                        cover_url: coverUrl,
                        tags: tags,
                        content: content,
                        author: authorName,
                        line_annotations: lineAnnotationsData
                    };
                    
                    sessionStorage.setItem('postPreviewData', JSON.stringify(previewData));
                    window.open('/posts/preview', '_blank', 'width=1000,height=800');
                });
            }
        }
    }

    let lineNumber = 0;
    const blocks = [];
    const annotationBlocks = [];

    const extractInlineAnnotationFromContent = (wrapper) => {
        // No longer parse # from content - keep text as-is
        // Annotations will come from dedicated input boxes
        return '';
    };

    const ensureControlBox = (wrapper) => {
        let box = wrapper.querySelector('.inline-actions-box');
        if (!box) {
            box = document.createElement('span');
            box.className = 'inline-actions-box';
            
            // Insert right after text content
            const contentHolder = wrapper.querySelector('.inline-line-content');
            if (contentHolder) {
                // Find the last text node or inline element in content holder
                const blockEl = contentHolder.querySelector('p, h1, h2, h3, h4, h5, h6');
                if (blockEl) {
                    // Append directly inside the block element to keep it inline
                    blockEl.appendChild(box);
                } else {
                    // Append to content holder for inline elements
                    contentHolder.appendChild(box);
                }
            } else {
                // Fallback: find the text element and insert after it
                const textEl = wrapper.querySelector('p, h1, h2, h3, h4, h5, h6, span');
                if (textEl && textEl.parentNode === wrapper) {
                    textEl.appendChild(box);
                } else {
                    wrapper.appendChild(box);
                }
            }
        }
        return box;
    };

    const panelPortalRoot = document.createElement('div');
    panelPortalRoot.className = 'inline-portal-root';
    postBody.appendChild(panelPortalRoot);

    const ensurePanelContainer = (wrapper) => {
        let container = panelPortalRoot.querySelector(`.inline-panel-container[data-line="${wrapper.dataset.line}"]`);
        if (!container) {
            container = document.createElement('div');
            container.className = 'inline-panel-container';
            container.dataset.line = wrapper.dataset.line;
            panelPortalRoot.appendChild(container);
        }
        return container;
    };

    const processedElements = [];
    
    // Also include div elements from Quill editor
    postBody.querySelectorAll('p, pre, blockquote, h1, h2, h3, h4, h5, h6, li, div.ql-editor > *').forEach(el => {
        if (el.querySelector('br')) {
            const parts = [];
            let currentPart = document.createElement('span');
            
            Array.from(el.childNodes).forEach(node => {
                if (node.nodeName === 'BR') {
                    if (currentPart.textContent.trim()) {
                        parts.push(currentPart);
                    }
                    currentPart = document.createElement('span');
                } else {
                    currentPart.appendChild(node.cloneNode(true));
                }
            });
            
            if (currentPart.textContent.trim()) {
                parts.push(currentPart);
            }
            
            el.innerHTML = '';
            parts.forEach((part, idx) => {
                if (idx > 0) el.appendChild(document.createElement('br'));
                el.appendChild(part);
                processedElements.push({ element: part, parent: el });
            });
        } else {
            processedElements.push({ element: el, parent: null });
        }
    });
    
    processedElements.forEach(({ element: el }) => {
        if (el.dataset.lineProcessed === 'true') return;

        const text = el.textContent.trim();
        const hasMedia = !!el.querySelector('img, figure, video, iframe');
        const tagName = el.tagName ? el.tagName.toLowerCase() : '';
        const isListItem = tagName === 'li';

        // Skip only if truly empty (not just "# comment")
        if (text.length === 0 && !hasMedia) return;

        lineNumber++;
        const currentLine = lineNumber;

        if (hasMedia && !isListItem) {
            el.dataset.line = currentLine;
            el.dataset.lineProcessed = 'true';
            el.classList.add('image-line');
            return;
        }

        let wrapper;

        if (isListItem) {
            el.dataset.line = currentLine;
            el.dataset.lineProcessed = 'true';
            el.classList.add('inline-list-item');

            if (el.querySelector(':scope > .inline-line')) {
                wrapper = el.querySelector(':scope > .inline-line');
            } else {
                wrapper = document.createElement('div');
                wrapper.className = 'inline-line';
                wrapper.dataset.line = currentLine;

                const contentHolder = document.createElement('span');
                contentHolder.className = 'inline-line-content';

                while (el.firstChild) {
                    contentHolder.appendChild(el.firstChild);
                }

                wrapper.appendChild(contentHolder);
                el.appendChild(wrapper);
            }
        } else {
            wrapper = document.createElement('span');
            wrapper.className = 'inline-line';
            wrapper.dataset.line = currentLine;
            wrapper.style.display = 'block';

            const contentHolder = document.createElement('span');
            contentHolder.className = 'inline-line-content';

            while (el.firstChild) {
                contentHolder.appendChild(el.firstChild);
            }

            el.dataset.lineProcessed = 'true';
            wrapper.appendChild(contentHolder);
            el.appendChild(wrapper);
        }

        const comments = lineComments[currentLine] || [];
        
        // Get annotation from backend data (no longer parse from content)
        const annotation = lineAnnotations[currentLine] || '';
        
        // Get clean text (no need to remove # since we don't parse it anymore)
        const cleanText = wrapper.textContent.trim();
        
        // Debug: log annotation data
        if (annotation) {
            console.log(`Line ${currentLine} has annotation:`, annotation);
        }
        
        const controlBox = ensureControlBox(wrapper);
        
        // Debug: ensure box is created
        if (!controlBox) {
            console.error('Failed to create control box for line', currentLine);
            return;
        }

        // Add annotation display if exists
        if (annotation) {
            // Check if annotation span already exists
            let annotationSpan = wrapper.querySelector('.line-annotation');
            if (!annotationSpan) {
                annotationSpan = document.createElement('span');
                annotationSpan.className = 'line-annotation';
                wrapper.appendChild(annotationSpan);
            }
            annotationSpan.textContent = `# ${annotation}`;
            annotationSpan.title = annotation;
        }

        if (isAuthor) {
            const annotateBtn = document.createElement('button');
            annotateBtn.type = 'button';
            annotateBtn.className = 'inline-btn annotate-btn';
            annotateBtn.innerHTML = `üìù`;
            annotateBtn.title = 'Ch√∫ th√≠ch';
            annotateBtn.dataset.line = currentLine;
            controlBox.appendChild(annotateBtn);

            const lineText = cleanText.length > 50 ? cleanText.substring(0, 50) + '...' : cleanText;
            const annotationPanel = document.createElement('div');
            annotationPanel.className = 'inline-panel annotation-panel';
            annotationPanel.hidden = true;
            annotationPanel.dataset.line = currentLine;
            annotationPanel.innerHTML = `
                <div class="inline-panel-header">
                    <span title="${cleanText}">${lineText}</span>
                    <button type="button" class="inline-close">√ó</button>
                </div>
                <form class="annotation-form" data-line="${currentLine}">
                    <textarea placeholder="Nh·∫≠p ch√∫ th√≠ch cho d√≤ng n√†y" minlength="1"></textarea>
                    <div class="annotation-actions">
                        <button type="submit" class="btn primary small">L∆∞u</button>
                        <button type="button" class="btn ghost small annotation-cancel">H·ªßy</button>
                    </div>
                    <p class="inline-error" hidden></p>
                </form>
            `;
            const annotationTextarea = annotationPanel.querySelector('textarea');
            annotationTextarea.value = annotation;
            ensurePanelContainer(wrapper).appendChild(annotationPanel);
            annotationBlocks.push({
                wrapper,
                button: annotateBtn,
                panel: annotationPanel,
                textarea: annotationTextarea,
                lineNumber: currentLine
            });
        }

        if (true) {
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'inline-btn';
            btn.innerHTML = `üí¨${comments.length > 0 ? ` <span>${comments.length}</span>` : ''}`;
            btn.dataset.line = currentLine;
            controlBox.appendChild(btn);

            const commentLineText = cleanText.length > 50 ? cleanText.substring(0, 50) + '...' : cleanText;
            const panel = document.createElement('div');
            panel.className = 'inline-panel';
            panel.hidden = true;
            panel.innerHTML = `
                <div class="inline-panel-header">
                    <span title="${cleanText}">${commentLineText}</span>
                    <button type="button" class="inline-close">√ó</button>
                </div>
                <div class="inline-comments">
                    ${comments.length > 0 ? comments.map(c => `
                        <div class="inline-comment">
                            <p style="white-space: pre-wrap; word-wrap: break-word;">${c.Content}</p>
                            <small>${c.AuthorName} ¬∑ ${c.CreatedAt}</small>
                        </div>
                    `).join('') : '<p class="inline-empty">Ch∆∞a c√≥ b√¨nh lu·∫≠n.</p>'}
                </div>
                ${isAuth ? `
                <form class="inline-form" data-line="${currentLine}">
                    <textarea placeholder="Th√™m b√¨nh lu·∫≠n..." required minlength="3"></textarea>
                    <button type="submit" class="btn primary small">G·ª≠i</button>
                    <p class="inline-error" hidden></p>
                </form>
                ` : ''}
            `;
            ensurePanelContainer(wrapper).appendChild(panel);
            blocks.push({ wrapper, btn, panel, lineNumber: currentLine });
        }
    });
    
    const closeAllCommentPanels = () => {
        blocks.forEach(b => {
            b.panel.hidden = true;
            b.wrapper.classList.remove('active');
        });
    };

    const closeAllAnnotationPanels = () => {
        annotationBlocks.forEach(b => {
            b.panel.hidden = true;
            b.wrapper.classList.remove('annotation-active');
        });
    };

    document.addEventListener('click', async (e) => {
        const annotateBtn = e.target.closest('.annotate-btn');
        const btn = e.target.closest('.inline-btn:not(.annotate-btn)');
        const close = e.target.closest('.inline-close');
        const cancelAnnotate = e.target.closest('.annotation-cancel');

        if (close) {
            e.preventDefault();
            e.stopPropagation();
            const panel = close.closest('.inline-panel');
            if (panel) {
                panel.hidden = true;
                const commentBlock = blocks.find(b => b.panel === panel);
                if (commentBlock) {
                    commentBlock.wrapper.classList.remove('active');
                }
                const annotationBlock = annotationBlocks.find(b => b.panel === panel);
                if (annotationBlock) {
                    annotationBlock.wrapper.classList.remove('annotation-active');
                }
            }
            return;
        }

        if (cancelAnnotate) {
            e.preventDefault();
            const panel = cancelAnnotate.closest('.inline-panel');
            if (panel) {
                panel.hidden = true;
                const annotationBlock = annotationBlocks.find(b => b.panel === panel);
                if (annotationBlock) {
                    annotationBlock.wrapper.classList.remove('annotation-active');
                    annotationBlock.textarea.value = lineAnnotations[annotationBlock.lineNumber] || '';
                }
            }
            return;
        }

        if (annotateBtn) {
            e.preventDefault();
            e.stopPropagation();
            const line = parseInt(annotateBtn.dataset.line);
            const block = annotationBlocks.find(b => b.lineNumber === line);
            if (block) {
                const wasHidden = block.panel.hidden;
                closeAllCommentPanels();
                closeAllAnnotationPanels();
                if (wasHidden) {
                    // Position panel at click location
                    const rect = annotateBtn.getBoundingClientRect();
                    block.panel.style.left = `${rect.left}px`;
                    block.panel.style.top = `${rect.bottom + 5}px`;
                    
                    block.panel.hidden = false;
                    block.wrapper.classList.add('annotation-active');
                    block.textarea.value = lineAnnotations[line] || '';
                    setTimeout(() => block.textarea.focus(), 0);
                }
            }
            return;
        }

        if (btn) {
            e.preventDefault();
            e.stopPropagation();
            const line = parseInt(btn.dataset.line);
            const block = blocks.find(b => b.lineNumber === line);
            if (block) {
                const wasHidden = block.panel.hidden;
                closeAllAnnotationPanels();
                blocks.forEach(b => {
                    b.panel.hidden = true;
                    b.wrapper.classList.remove('active');
                });
                if (wasHidden) {
                    // Position panel at click location
                    const rect = btn.getBoundingClientRect();
                    block.panel.style.left = `${rect.left}px`;
                    block.panel.style.top = `${rect.bottom + 5}px`;
                    
                    block.panel.hidden = false;
                    block.wrapper.classList.add('active');
                }
            }
            return;
        }

        if (!e.target.closest('.inline-panel')) {
            closeAllCommentPanels();
            closeAllAnnotationPanels();
        }
    });

    if (isAuth || isAuthor) {
        document.addEventListener('submit', async (e) => {
            const form = e.target;
            if (!form.classList.contains('inline-form') && !form.classList.contains('annotation-form')) return;
            e.preventDefault();
            
            const line = parseInt(form.dataset.line);
            const textarea = form.querySelector('textarea');
            const error = form.querySelector('.inline-error');
            const submitBtn = form.querySelector('button[type="submit"]');

            error.hidden = true;
            const content = textarea.value.trim();

            if (form.classList.contains('inline-form')) {
                if (content.length < 3) {
                    error.textContent = 'B√¨nh lu·∫≠n ph·∫£i t·ª´ 3 k√Ω t·ª±.';
                    error.hidden = false;
                    return;
                }

                submitBtn.disabled = true;
                try {
                    const res = await fetch(`/posts/${postId}/comments`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ content, line_number: parseInt(line) })
                    });

                    if (!res.ok) throw new Error('Kh√¥ng th·ªÉ g·ª≠i b√¨nh lu·∫≠n');
                    
                    const data = await res.json();
                    const commentsDiv = form.previousElementSibling;
                    const empty = commentsDiv.querySelector('.inline-empty');
                    if (empty) empty.remove();

                    const newComment = document.createElement('div');
                    newComment.className = 'inline-comment new';
                    newComment.innerHTML = `
                        <p style="white-space: pre-wrap; word-wrap: break-word;">${data.comment.content}</p>
                        <small>${data.comment.author_name} ¬∑ ${data.comment.created_at}</small>
                    `;
                    commentsDiv.appendChild(newComment);
                    textarea.value = '';

                    const block = blocks.find(b => b.lineNumber === line);
                    if (block) {
                        block.wrapper.classList.add('highlight');
                        setTimeout(() => block.wrapper.classList.remove('highlight'), 2000);
                        const countSpan = block.btn.querySelector('span');
                        if (countSpan) {
                            countSpan.textContent = parseInt(countSpan.textContent) + 1;
                        } else {
                            block.btn.innerHTML += ` <span>1</span>`;
                        }
                    }
                } catch (err) {
                    error.textContent = err.message;
                    error.hidden = false;
                } finally {
                    submitBtn.disabled = false;
                }
                return;
            }

            // Annotation form handling
            const currentAnnotation = lineAnnotations[line] || '';
            if (content === currentAnnotation) {
                const block = annotationBlocks.find(b => b.lineNumber === line);
                if (block) {
                    block.panel.hidden = true;
                    block.wrapper.classList.remove('annotation-active');
                }
                return;
            }

            submitBtn.disabled = true;
            try {
                const res = await fetch(`/posts/${postId}/annotations`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ content, line_number: line })
                });

                if (!res.ok) {
                    const errorData = await res.json();
                    console.error('Error response:', errorData);
                    throw new Error(errorData.error || 'Kh√¥ng th·ªÉ l∆∞u ch√∫ th√≠ch');
                }

                lineAnnotations[line] = content;

                const block = annotationBlocks.find(b => b.lineNumber === line);
                if (block) {
                    block.panel.hidden = true;
                    block.wrapper.classList.remove('annotation-active');
                }

                const wrapper = document.querySelector(`.inline-line[data-line="${line}"]`);
                if (wrapper) {
                    // Live update: Sync to edit mode notice input if exists
                    const noticeInput = document.querySelector(`#edit-notice-overlay input[data-line="${line}"]`);
                    if (noticeInput) {
                        noticeInput.value = content;
                    }

                    // C·∫≠p nh·∫≠t hi·ªÉn th·ªã annotation span
                    let annotationSpan = wrapper.querySelector('.line-annotation');
                    if (content) {
                        if (!annotationSpan) {
                            annotationSpan = document.createElement('span');
                            annotationSpan.className = 'line-annotation';
                            wrapper.appendChild(annotationSpan);
                        }
                        annotationSpan.textContent = `# ${content}`;
                        annotationSpan.title = content;
                        
                        // Add highlight effect for live update
                        wrapper.classList.add('annotation-highlight');
                        setTimeout(() => wrapper.classList.remove('annotation-highlight'), 2000);
                    } else if (annotationSpan) {
                        annotationSpan.remove();
                    }
                    
                    // Update textarea value in the panel
                    const block = annotationBlocks.find(b => b.lineNumber === line);
                    if (block && block.textarea) {
                        block.textarea.value = content;
                    }
                    
                    // Update postBody HTML for edit form
                    // C·∫≠p nh·∫≠t n·ªôi dung trong postBody ƒë·ªÉ khi m·ªü editor s·∫Ω c√≥ gi√° tr·ªã m·ªõi
                    const editTextarea = document.getElementById('edit-content-textarea');
                    if (editTextarea) {
                        editTextarea.value = postBody.innerHTML;
                    }
                    
                    // Live update Quill editor if it's already initialized
                    if (editQuill) {
                        const delta = editQuill.clipboard.convert(postBody.innerHTML);
                        editQuill.setContents(delta, 'silent');
                    }
                }
            } catch (err) {
                error.textContent = err.message;
                error.hidden = false;
            } finally {
                submitBtn.disabled = false;
            }
        });
    }
});
</script>